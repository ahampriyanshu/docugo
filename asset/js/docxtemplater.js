window["docxtemplater"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./es6/docxtemplater.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./es6/browser-versions/xmldom.js":
/*!****************************************!*\
  !*** ./es6/browser-versions/xmldom.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {\n  XMLSerializer: window.XMLSerializer,\n  DOMParser: window.DOMParser,\n  XMLDocument: window.XMLDocument\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/browser-versions/xmldom.js?");

/***/ }),

/***/ "./es6/collect-content-types.js":
/*!**************************************!*\
  !*** ./es6/collect-content-types.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var ctXML = \"[Content_Types].xml\";\n\nfunction collectContentTypes(overrides, defaults, zip) {\n  var partNames = {};\n\n  for (var i = 0, len = overrides.length; i < len; i++) {\n    var override = overrides[i];\n    var contentType = override.getAttribute(\"ContentType\");\n    var partName = override.getAttribute(\"PartName\").substr(1);\n    partNames[partName] = contentType;\n  }\n\n  var _loop = function _loop(_i, _len) {\n    var def = defaults[_i];\n    var contentType = def.getAttribute(\"ContentType\");\n    var extension = def.getAttribute(\"Extension\"); // eslint-disable-next-line no-loop-func\n\n    zip.file(/./).map(function (_ref) {\n      var name = _ref.name;\n\n      if (name.slice(name.length - extension.length - 1) === \".xml\" && !partNames[name] && name !== ctXML) {\n        partNames[name] = contentType;\n      }\n    });\n  };\n\n  for (var _i = 0, _len = defaults.length; _i < _len; _i++) {\n    _loop(_i, _len);\n  }\n\n  return partNames;\n}\n\nmodule.exports = collectContentTypes;\n\n//# sourceURL=webpack://docxtemplater/./es6/collect-content-types.js?");

/***/ }),

/***/ "./es6/doc-utils.js":
/*!**************************!*\
  !*** ./es6/doc-utils.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar _require = __webpack_require__(/*! xmldom */ \"./es6/browser-versions/xmldom.js\"),\n    DOMParser = _require.DOMParser,\n    XMLSerializer = _require.XMLSerializer;\n\nvar _require2 = __webpack_require__(/*! ./errors */ \"./es6/errors.js\"),\n    throwXmlTagNotFound = _require2.throwXmlTagNotFound;\n\nvar _require3 = __webpack_require__(/*! ./utils */ \"./es6/utils.js\"),\n    last = _require3.last,\n    first = _require3.first;\n\nfunction parser(tag) {\n  return {\n    get: function get(scope) {\n      if (tag === \".\") {\n        return scope;\n      }\n\n      return scope[tag];\n    }\n  };\n}\n\nfunction getNearestLeftIndex(parsed, elements, index) {\n  for (var i = index; i >= 0; i--) {\n    var part = parsed[i];\n\n    for (var j = 0, len = elements.length; j < len; j++) {\n      var element = elements[j];\n\n      if (isStarting(part.value, element)) {\n        return j;\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction getNearestRightIndex(parsed, elements, index) {\n  for (var i = index, l = parsed.length; i < l; i++) {\n    var part = parsed[i];\n\n    for (var j = 0, len = elements.length; j < len; j++) {\n      var element = elements[j];\n\n      if (isEnding(part.value, element)) {\n        return j;\n      }\n    }\n  }\n\n  return -1;\n}\n\nfunction getNearestLeft(parsed, elements, index) {\n  var found = getNearestLeftIndex(parsed, elements, index);\n\n  if (found !== -1) {\n    return elements[found];\n  }\n\n  return null;\n}\n\nfunction getNearestRight(parsed, elements, index) {\n  var found = getNearestRightIndex(parsed, elements, index);\n\n  if (found !== -1) {\n    return elements[found];\n  }\n\n  return null;\n}\n\nfunction buildNearestCache(postparsed, tags) {\n  return postparsed.reduce(function (cached, part, i) {\n    if (part.type === \"tag\" && tags.indexOf(part.tag) !== -1) {\n      cached.push({\n        i: i,\n        part: part\n      });\n    }\n\n    return cached;\n  }, []);\n}\n\nfunction getNearestLeftIndexWithCache(index, cache) {\n  if (cache.length === 0) {\n    return -1;\n  }\n\n  for (var i = 0, len = cache.length; i < len; i++) {\n    var current = cache[i];\n    var next = cache[i + 1];\n\n    if (current.i < index && (!next || index < next.i) && current.part.position === \"start\") {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction getNearestLeftWithCache(index, cache) {\n  var found = getNearestLeftIndexWithCache(index, cache);\n\n  if (found !== -1) {\n    return cache[found].part.tag;\n  }\n\n  return null;\n}\n\nfunction getNearestRightIndexWithCache(index, cache) {\n  if (cache.length === 0) {\n    return -1;\n  }\n\n  for (var i = 0, len = cache.length; i < len; i++) {\n    var current = cache[i];\n    var _last = cache[i - 1];\n\n    if (index < current.i && (!_last || _last.i < index) && current.part.position === \"end\") {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction getNearestRightWithCache(index, cache) {\n  var found = getNearestRightIndexWithCache(index, cache);\n\n  if (found !== -1) {\n    return cache[found].part.tag;\n  }\n\n  return null;\n}\n\nfunction endsWith(str, suffix) {\n  return str.indexOf(suffix, str.length - suffix.length) !== -1;\n}\n\nfunction startsWith(str, prefix) {\n  return str.substring(0, prefix.length) === prefix;\n}\n\nfunction unique(arr) {\n  var hash = {},\n      result = [];\n\n  for (var i = 0, l = arr.length; i < l; ++i) {\n    if (!hash.hasOwnProperty(arr[i])) {\n      hash[arr[i]] = true;\n      result.push(arr[i]);\n    }\n  }\n\n  return result;\n}\n\nfunction chunkBy(parsed, f) {\n  return parsed.reduce(function (chunks, p) {\n    var currentChunk = last(chunks);\n    var res = f(p);\n\n    if (currentChunk.length === 0) {\n      currentChunk.push(p);\n      return chunks;\n    }\n\n    if (res === \"start\") {\n      chunks.push([p]);\n    } else if (res === \"end\") {\n      currentChunk.push(p);\n      chunks.push([]);\n    } else {\n      currentChunk.push(p);\n    }\n\n    return chunks;\n  }, [[]]).filter(function (p) {\n    return p.length > 0;\n  });\n}\n\nvar defaults = {\n  paragraphLoop: false,\n  nullGetter: function nullGetter(part) {\n    if (!part.module) {\n      return \"undefined\";\n    }\n\n    if (part.module === \"rawxml\") {\n      return \"\";\n    }\n\n    return \"\";\n  },\n  xmlFileNames: [],\n  parser: parser,\n  linebreaks: false,\n  fileTypeConfig: null,\n  delimiters: {\n    start: \"{\",\n    end: \"}\"\n  }\n};\n\nfunction mergeObjects() {\n  var resObj = {};\n  var obj, keys;\n\n  for (var i = 0; i < arguments.length; i += 1) {\n    obj = arguments[i];\n    keys = Object.keys(obj);\n\n    for (var j = 0; j < keys.length; j += 1) {\n      resObj[keys[j]] = obj[keys[j]];\n    }\n  }\n\n  return resObj;\n}\n\nfunction xml2str(xmlNode) {\n  var a = new XMLSerializer();\n  return a.serializeToString(xmlNode).replace(/xmlns(:[a-z0-9]+)?=\"\" ?/g, \"\");\n}\n\nfunction str2xml(str) {\n  if (str.charCodeAt(0) === 65279) {\n    // BOM sequence\n    str = str.substr(1);\n  }\n\n  var parser = new DOMParser();\n  return parser.parseFromString(str, \"text/xml\");\n}\n\nvar charMap = [[\"&\", \"&amp;\"], [\"<\", \"&lt;\"], [\">\", \"&gt;\"], ['\"', \"&quot;\"], [\"'\", \"&apos;\"]];\n\nfunction escapeRegExp(str) {\n  // to be able to use a string as a regex\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n\nvar charMapRegexes = charMap.map(function (_ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      endChar = _ref2[0],\n      startChar = _ref2[1];\n\n  return {\n    rstart: new RegExp(escapeRegExp(startChar), \"g\"),\n    rend: new RegExp(escapeRegExp(endChar), \"g\"),\n    start: startChar,\n    end: endChar\n  };\n});\n\nfunction wordToUtf8(string) {\n  var r;\n\n  for (var i = charMapRegexes.length - 1; i >= 0; i--) {\n    r = charMapRegexes[i];\n    string = string.replace(r.rstart, r.end);\n  }\n\n  return string;\n}\n\nfunction utf8ToWord(string) {\n  if (typeof string !== \"string\") {\n    string = string.toString();\n  }\n\n  var r;\n\n  for (var i = 0, l = charMapRegexes.length; i < l; i++) {\n    r = charMapRegexes[i];\n    string = string.replace(r.rend, r.start);\n  }\n\n  return string;\n} // This function is written with for loops for performance\n\n\nfunction concatArrays(arrays) {\n  var result = [];\n\n  for (var i = 0; i < arrays.length; i++) {\n    var array = arrays[i];\n\n    for (var j = 0, len = array.length; j < len; j++) {\n      result.push(array[j]);\n    }\n  }\n\n  return result;\n}\n\nvar spaceRegexp = new RegExp(String.fromCharCode(160), \"g\");\n\nfunction convertSpaces(s) {\n  return s.replace(spaceRegexp, \" \");\n}\n\nfunction pregMatchAll(regex, content) {\n  /* regex is a string, content is the content. It returns an array of all matches with their offset, for example:\n  \t regex=la\n  \t content=lolalolilala\n  returns: [{array: {0: 'la'},offset: 2},{array: {0: 'la'},offset: 8},{array: {0: 'la'} ,offset: 10}]\n  */\n  var matchArray = [];\n  var match;\n\n  while ((match = regex.exec(content)) != null) {\n    matchArray.push({\n      array: match,\n      offset: match.index\n    });\n  }\n\n  return matchArray;\n}\n\nfunction isEnding(value, element) {\n  return value === \"</\" + element + \">\";\n}\n\nfunction isStarting(value, element) {\n  return value.indexOf(\"<\" + element) === 0 && [\">\", \" \"].indexOf(value[element.length + 1]) !== -1;\n}\n\nfunction getRight(parsed, element, index) {\n  var val = getRightOrNull(parsed, element, index);\n\n  if (val !== null) {\n    return val;\n  }\n\n  throwXmlTagNotFound({\n    position: \"right\",\n    element: element,\n    parsed: parsed,\n    index: index\n  });\n}\n\nfunction getRightOrNull(parsed, elements, index) {\n  if (typeof elements === \"string\") {\n    elements = [elements];\n  }\n\n  var level = 1;\n\n  for (var i = index, l = parsed.length; i < l; i++) {\n    var part = parsed[i];\n\n    for (var j = 0, len = elements.length; j < len; j++) {\n      var element = elements[j];\n\n      if (isEnding(part.value, element)) {\n        level--;\n      }\n\n      if (isStarting(part.value, element)) {\n        level++;\n      }\n\n      if (level === 0) {\n        return i;\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction getLeft(parsed, element, index) {\n  var val = getLeftOrNull(parsed, element, index);\n\n  if (val !== null) {\n    return val;\n  }\n\n  throwXmlTagNotFound({\n    position: \"left\",\n    element: element,\n    parsed: parsed,\n    index: index\n  });\n}\n\nfunction getLeftOrNull(parsed, elements, index) {\n  if (typeof elements === \"string\") {\n    elements = [elements];\n  }\n\n  var level = 1;\n\n  for (var i = index; i >= 0; i--) {\n    var part = parsed[i];\n\n    for (var j = 0, len = elements.length; j < len; j++) {\n      var element = elements[j];\n\n      if (isStarting(part.value, element)) {\n        level--;\n      }\n\n      if (isEnding(part.value, element)) {\n        level++;\n      }\n\n      if (level === 0) {\n        return i;\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction isTagStart(tagType, _ref3) {\n  var type = _ref3.type,\n      tag = _ref3.tag,\n      position = _ref3.position;\n  return type === \"tag\" && tag === tagType && position === \"start\";\n}\n\nfunction isTagEnd(tagType, _ref4) {\n  var type = _ref4.type,\n      tag = _ref4.tag,\n      position = _ref4.position;\n  return type === \"tag\" && tag === tagType && position === \"end\";\n}\n\nfunction isParagraphStart(options) {\n  return isTagStart(\"w:p\", options) || isTagStart(\"a:p\", options);\n}\n\nfunction isParagraphEnd(options) {\n  return isTagEnd(\"w:p\", options) || isTagEnd(\"a:p\", options);\n}\n\nfunction isTextStart(part) {\n  return part.type === \"tag\" && part.position === \"start\" && part.text;\n}\n\nfunction isTextEnd(part) {\n  return part.type === \"tag\" && part.position === \"end\" && part.text;\n}\n\nfunction isContent(p) {\n  return p.type === \"placeholder\" || p.type === \"content\" && p.position === \"insidetag\";\n}\n\nvar corruptCharacters = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/; // 00    NUL '\\0' (null character)\n// 01    SOH (start of heading)\n// 02    STX (start of text)\n// 03    ETX (end of text)\n// 04    EOT (end of transmission)\n// 05    ENQ (enquiry)\n// 06    ACK (acknowledge)\n// 07    BEL '\\a' (bell)\n// 08    BS  '\\b' (backspace)\n// 0B    VT  '\\v' (vertical tab)\n// 0C    FF  '\\f' (form feed)\n// 0E    SO  (shift out)\n// 0F    SI  (shift in)\n// 10    DLE (data link escape)\n// 11    DC1 (device control 1)\n// 12    DC2 (device control 2)\n// 13    DC3 (device control 3)\n// 14    DC4 (device control 4)\n// 15    NAK (negative ack.)\n// 16    SYN (synchronous idle)\n// 17    ETB (end of trans. blk)\n// 18    CAN (cancel)\n// 19    EM  (end of medium)\n// 1A    SUB (substitute)\n// 1B    ESC (escape)\n// 1C    FS  (file separator)\n// 1D    GS  (group separator)\n// 1E    RS  (record separator)\n// 1F    US  (unit separator)\n\nfunction hasCorruptCharacters(string) {\n  return corruptCharacters.test(string);\n}\n\nfunction invertMap(map) {\n  return Object.keys(map).reduce(function (invertedMap, key) {\n    var value = map[key];\n    invertedMap[value] = invertedMap[value] || [];\n    invertedMap[value].push(key);\n    return invertedMap;\n  }, {});\n}\n\nmodule.exports = {\n  endsWith: endsWith,\n  startsWith: startsWith,\n  getNearestLeft: getNearestLeft,\n  getNearestRight: getNearestRight,\n  getNearestLeftWithCache: getNearestLeftWithCache,\n  getNearestRightWithCache: getNearestRightWithCache,\n  getNearestLeftIndex: getNearestLeftIndex,\n  getNearestRightIndex: getNearestRightIndex,\n  getNearestLeftIndexWithCache: getNearestLeftIndexWithCache,\n  getNearestRightIndexWithCache: getNearestRightIndexWithCache,\n  buildNearestCache: buildNearestCache,\n  isContent: isContent,\n  isParagraphStart: isParagraphStart,\n  isParagraphEnd: isParagraphEnd,\n  isTagStart: isTagStart,\n  isTagEnd: isTagEnd,\n  isTextStart: isTextStart,\n  isTextEnd: isTextEnd,\n  unique: unique,\n  chunkBy: chunkBy,\n  last: last,\n  first: first,\n  mergeObjects: mergeObjects,\n  xml2str: xml2str,\n  str2xml: str2xml,\n  getRightOrNull: getRightOrNull,\n  getRight: getRight,\n  getLeftOrNull: getLeftOrNull,\n  getLeft: getLeft,\n  pregMatchAll: pregMatchAll,\n  convertSpaces: convertSpaces,\n  escapeRegExp: escapeRegExp,\n  charMapRegexes: charMapRegexes,\n  hasCorruptCharacters: hasCorruptCharacters,\n  defaults: defaults,\n  wordToUtf8: wordToUtf8,\n  utf8ToWord: utf8ToWord,\n  concatArrays: concatArrays,\n  invertMap: invertMap,\n  charMap: charMap\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/doc-utils.js?");

/***/ }),

/***/ "./es6/docxtemplater.js":
/*!******************************!*\
  !*** ./es6/docxtemplater.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar DocUtils = __webpack_require__(/*! ./doc-utils */ \"./es6/doc-utils.js\");\n\nDocUtils.traits = __webpack_require__(/*! ./traits */ \"./es6/traits.js\");\nDocUtils.moduleWrapper = __webpack_require__(/*! ./module-wrapper */ \"./es6/module-wrapper.js\");\n\nvar createScope = __webpack_require__(/*! ./scope-manager */ \"./es6/scope-manager.js\");\n\nvar _require = __webpack_require__(/*! ./errors */ \"./es6/errors.js\"),\n    throwMultiError = _require.throwMultiError,\n    throwResolveBeforeCompile = _require.throwResolveBeforeCompile,\n    throwRenderInvalidTemplate = _require.throwRenderInvalidTemplate;\n\nvar collectContentTypes = __webpack_require__(/*! ./collect-content-types */ \"./es6/collect-content-types.js\");\n\nvar ctXML = \"[Content_Types].xml\";\n\nvar commonModule = __webpack_require__(/*! ./modules/common */ \"./es6/modules/common.js\");\n\nvar Lexer = __webpack_require__(/*! ./lexer */ \"./es6/lexer.js\");\n\nvar defaults = DocUtils.defaults,\n    str2xml = DocUtils.str2xml,\n    xml2str = DocUtils.xml2str,\n    moduleWrapper = DocUtils.moduleWrapper,\n    utf8ToWord = DocUtils.utf8ToWord,\n    concatArrays = DocUtils.concatArrays,\n    unique = DocUtils.unique;\n\nvar _require2 = __webpack_require__(/*! ./errors */ \"./es6/errors.js\"),\n    XTInternalError = _require2.XTInternalError,\n    throwFileTypeNotIdentified = _require2.throwFileTypeNotIdentified,\n    throwFileTypeNotHandled = _require2.throwFileTypeNotHandled,\n    throwApiVersionError = _require2.throwApiVersionError;\n\nvar currentModuleApiVersion = [3, 25, 0];\n\nvar Docxtemplater = /*#__PURE__*/function () {\n  function Docxtemplater(zip) {\n    var _this = this;\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$modules = _ref.modules,\n        modules = _ref$modules === void 0 ? [] : _ref$modules,\n        options = _objectWithoutProperties(_ref, [\"modules\"]);\n\n    _classCallCheck(this, Docxtemplater);\n\n    if (!Array.isArray(modules)) {\n      throw new Error(\"The modules argument of docxtemplater's constructor must be an array\");\n    }\n\n    this.scopeManagers = {};\n    this.compiled = {};\n    this.modules = [commonModule()];\n    this.setOptions(options);\n    modules.forEach(function (module) {\n      _this.attachModule(module);\n    });\n\n    if (arguments.length > 0) {\n      if (!zip || !zip.files || typeof zip.file !== \"function\") {\n        throw new Error(\"The first argument of docxtemplater's constructor must be a valid zip file (jszip v2 or pizzip v3)\");\n      }\n\n      this.loadZip(zip); // remove the unsupported modules\n\n      this.modules = this.modules.filter(function (module) {\n        if (module.supportedFileTypes) {\n          if (!Array.isArray(module.supportedFileTypes)) {\n            throw new Error(\"The supportedFileTypes field of the module must be an array\");\n          }\n\n          var isSupportedModule = module.supportedFileTypes.indexOf(_this.fileType) !== -1;\n\n          if (!isSupportedModule) {\n            module.on(\"detached\");\n          }\n\n          return isSupportedModule;\n        }\n\n        return true;\n      });\n      this.compile();\n      this.v4Constructor = true;\n    }\n  }\n\n  _createClass(Docxtemplater, [{\n    key: \"getModuleApiVersion\",\n    value: function getModuleApiVersion() {\n      return currentModuleApiVersion.join(\".\");\n    }\n  }, {\n    key: \"verifyApiVersion\",\n    value: function verifyApiVersion(neededVersion) {\n      neededVersion = neededVersion.split(\".\").map(function (i) {\n        return parseInt(i, 10);\n      });\n\n      if (neededVersion.length !== 3) {\n        throwApiVersionError(\"neededVersion is not a valid version\", {\n          neededVersion: neededVersion,\n          explanation: \"the neededVersion must be an array of length 3\"\n        });\n      }\n\n      if (neededVersion[0] !== currentModuleApiVersion[0]) {\n        throwApiVersionError(\"The major api version do not match, you probably have to update docxtemplater with npm install --save docxtemplater\", {\n          neededVersion: neededVersion,\n          currentModuleApiVersion: currentModuleApiVersion,\n          explanation: \"moduleAPIVersionMismatch : needed=\".concat(neededVersion.join(\".\"), \", current=\").concat(currentModuleApiVersion.join(\".\"))\n        });\n      }\n\n      if (neededVersion[1] > currentModuleApiVersion[1]) {\n        throwApiVersionError(\"The minor api version is not uptodate, you probably have to update docxtemplater with npm install --save docxtemplater\", {\n          neededVersion: neededVersion,\n          currentModuleApiVersion: currentModuleApiVersion,\n          explanation: \"moduleAPIVersionMismatch : needed=\".concat(neededVersion.join(\".\"), \", current=\").concat(currentModuleApiVersion.join(\".\"))\n        });\n      }\n\n      if (neededVersion[1] === currentModuleApiVersion[1] && neededVersion[2] > currentModuleApiVersion[2]) {\n        throwApiVersionError(\"The patch api version is not uptodate, you probably have to update docxtemplater with npm install --save docxtemplater\", {\n          neededVersion: neededVersion,\n          currentModuleApiVersion: currentModuleApiVersion,\n          explanation: \"moduleAPIVersionMismatch : needed=\".concat(neededVersion.join(\".\"), \", current=\").concat(currentModuleApiVersion.join(\".\"))\n        });\n      }\n\n      return true;\n    }\n  }, {\n    key: \"setModules\",\n    value: function setModules(obj) {\n      this.modules.forEach(function (module) {\n        module.set(obj);\n      });\n    }\n  }, {\n    key: \"sendEvent\",\n    value: function sendEvent(eventName) {\n      this.modules.forEach(function (module) {\n        module.on(eventName);\n      });\n    }\n  }, {\n    key: \"attachModule\",\n    value: function attachModule(module) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.v4Constructor) {\n        throw new Error(\"attachModule() should not be called manually when using the v4 constructor\");\n      }\n\n      if (module.requiredAPIVersion) {\n        this.verifyApiVersion(module.requiredAPIVersion);\n      }\n\n      if (module.attached === true) {\n        throw new Error(\"Cannot attach a module that was already attached : \\\"\".concat(module.name, \"\\\". Maybe you are instantiating the module at the root level, and using it for multiple instances of Docxtemplater\"));\n      }\n\n      module.attached = true;\n      var prefix = options.prefix;\n\n      if (prefix) {\n        module.prefix = prefix;\n      }\n\n      var wrappedModule = moduleWrapper(module);\n      this.modules.push(wrappedModule);\n      wrappedModule.on(\"attached\");\n      return this;\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      var _this2 = this;\n\n      if (this.v4Constructor) {\n        throw new Error(\"setOptions() should not be called manually when using the v4 constructor\");\n      }\n\n      if (!options) {\n        throw new Error(\"setOptions should be called with an object as first parameter\");\n      }\n\n      if (options.delimiters) {\n        options.delimiters.start = utf8ToWord(options.delimiters.start);\n        options.delimiters.end = utf8ToWord(options.delimiters.end);\n      }\n\n      this.options = {};\n      Object.keys(defaults).forEach(function (key) {\n        var defaultValue = defaults[key];\n        _this2.options[key] = options[key] != null ? options[key] : defaultValue;\n        _this2[key] = _this2.options[key];\n      });\n\n      if (this.zip) {\n        this.updateFileTypeConfig();\n      }\n\n      return this;\n    }\n  }, {\n    key: \"loadZip\",\n    value: function loadZip(zip) {\n      if (zip.loadAsync) {\n        throw new XTInternalError(\"Docxtemplater doesn't handle JSZip version >=3, please use pizzip\");\n      }\n\n      this.zip = zip;\n      this.updateFileTypeConfig();\n      this.modules = concatArrays([this.fileTypeConfig.baseModules.map(function (moduleFunction) {\n        return moduleFunction();\n      }), this.modules]);\n      return this;\n    }\n  }, {\n    key: \"compileFile\",\n    value: function compileFile(fileName) {\n      this.compiled[fileName].parse();\n    }\n  }, {\n    key: \"precompileFile\",\n    value: function precompileFile(fileName) {\n      var currentFile = this.createTemplateClass(fileName);\n      currentFile.preparse();\n      this.compiled[fileName] = currentFile;\n    }\n  }, {\n    key: \"getScopeManager\",\n    value: function getScopeManager(to, currentFile, tags) {\n      if (!this.scopeManagers[to]) {\n        this.scopeManagers[to] = createScope({\n          tags: tags || {},\n          parser: this.parser,\n          cachedParsers: currentFile.cachedParsers\n        });\n      }\n\n      return this.scopeManagers[to];\n    }\n  }, {\n    key: \"resolveData\",\n    value: function resolveData(data) {\n      var _this3 = this;\n\n      var errors = [];\n\n      if (!Object.keys(this.compiled).length) {\n        throwResolveBeforeCompile();\n      }\n\n      return Promise.resolve(data).then(function (data) {\n        _this3.setData(data);\n\n        _this3.setModules({\n          data: _this3.data,\n          Lexer: Lexer\n        });\n\n        _this3.mapper = _this3.modules.reduce(function (value, module) {\n          return module.getRenderedMap(value);\n        }, {});\n        return Promise.all(Object.keys(_this3.mapper).map(function (to) {\n          var _this3$mapper$to = _this3.mapper[to],\n              from = _this3$mapper$to.from,\n              data = _this3$mapper$to.data;\n          return Promise.resolve(data).then(function (data) {\n            var currentFile = _this3.compiled[from];\n            currentFile.filePath = to;\n            currentFile.scopeManager = _this3.getScopeManager(to, currentFile, data);\n            currentFile.scopeManager.resolved = [];\n            return currentFile.resolveTags(data).then(function (result) {\n              currentFile.scopeManager.finishedResolving = true;\n              return result;\n            }, function (errs) {\n              errors = errors.concat(errs);\n            });\n          });\n        })).then(function (resolved) {\n          if (errors.length !== 0) {\n            throwMultiError(errors);\n          }\n\n          return concatArrays(resolved);\n        });\n      });\n    }\n  }, {\n    key: \"compile\",\n    value: function compile() {\n      var _this4 = this;\n\n      if (Object.keys(this.compiled).length) {\n        return this;\n      }\n\n      this.options = this.modules.reduce(function (options, module) {\n        return module.optionsTransformer(options, _this4);\n      }, this.options);\n      this.options.xmlFileNames = unique(this.options.xmlFileNames);\n      this.xmlDocuments = this.options.xmlFileNames.reduce(function (xmlDocuments, fileName) {\n        var content = _this4.zip.files[fileName].asText();\n\n        xmlDocuments[fileName] = str2xml(content);\n        return xmlDocuments;\n      }, {});\n      this.setModules({\n        zip: this.zip,\n        xmlDocuments: this.xmlDocuments\n      });\n      this.getTemplatedFiles();\n      this.setModules({\n        compiled: this.compiled\n      }); // Loop inside all templatedFiles (ie xml files with content).\n      // Sometimes they don't exist (footer.xml for example)\n\n      this.templatedFiles.forEach(function (fileName) {\n        if (_this4.zip.files[fileName] != null) {\n          _this4.precompileFile(fileName);\n        }\n      });\n      this.templatedFiles.forEach(function (fileName) {\n        if (_this4.zip.files[fileName] != null) {\n          _this4.compileFile(fileName);\n        }\n      });\n      verifyErrors(this);\n      return this;\n    }\n  }, {\n    key: \"updateFileTypeConfig\",\n    value: function updateFileTypeConfig() {\n      var _this5 = this;\n\n      var fileType;\n\n      if (this.zip.files.mimetype) {\n        fileType = \"odt\";\n      }\n\n      var contentTypes = this.zip.files[ctXML];\n      this.targets = [];\n      var contentTypeXml = contentTypes ? str2xml(contentTypes.asText()) : null;\n      var overrides = contentTypeXml ? contentTypeXml.getElementsByTagName(\"Override\") : null;\n      var defaults = contentTypeXml ? contentTypeXml.getElementsByTagName(\"Default\") : null;\n\n      if (contentTypeXml) {\n        this.filesContentTypes = collectContentTypes(overrides, defaults, this.zip);\n        this.invertedContentTypes = DocUtils.invertMap(this.filesContentTypes);\n        this.setModules({\n          contentTypes: this.contentTypes,\n          invertedContentTypes: this.invertedContentTypes\n        });\n      }\n\n      this.modules.forEach(function (module) {\n        fileType = module.getFileType({\n          zip: _this5.zip,\n          contentTypes: contentTypes,\n          contentTypeXml: contentTypeXml,\n          overrides: overrides,\n          defaults: defaults,\n          doc: _this5\n        }) || fileType;\n      });\n\n      if (fileType === \"odt\") {\n        throwFileTypeNotHandled(fileType);\n      }\n\n      if (!fileType) {\n        throwFileTypeNotIdentified();\n      }\n\n      this.fileType = fileType;\n      this.fileTypeConfig = this.options.fileTypeConfig || this.fileTypeConfig || Docxtemplater.FileTypeConfig[this.fileType]();\n      return this;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this6 = this;\n\n      this.compile();\n\n      if (this.errors.length > 0) {\n        throwRenderInvalidTemplate();\n      }\n\n      this.setModules({\n        data: this.data,\n        Lexer: Lexer\n      });\n      this.mapper = this.modules.reduce(function (value, module) {\n        return module.getRenderedMap(value);\n      }, {});\n      this.fileTypeConfig.tagsXmlLexedArray = unique(this.fileTypeConfig.tagsXmlLexedArray);\n      this.fileTypeConfig.tagsXmlTextArray = unique(this.fileTypeConfig.tagsXmlTextArray);\n      Object.keys(this.mapper).forEach(function (to) {\n        var _this6$mapper$to = _this6.mapper[to],\n            from = _this6$mapper$to.from,\n            data = _this6$mapper$to.data;\n        var currentFile = _this6.compiled[from];\n        currentFile.setTags(data);\n        currentFile.scopeManager = _this6.getScopeManager(to, currentFile, data);\n        currentFile.render(to);\n\n        _this6.zip.file(to, currentFile.content, {\n          createFolders: true\n        });\n      });\n      verifyErrors(this);\n      this.sendEvent(\"syncing-zip\");\n      this.syncZip();\n      return this;\n    }\n  }, {\n    key: \"syncZip\",\n    value: function syncZip() {\n      var _this7 = this;\n\n      Object.keys(this.xmlDocuments).forEach(function (fileName) {\n        _this7.zip.remove(fileName);\n\n        var content = xml2str(_this7.xmlDocuments[fileName]);\n        return _this7.zip.file(fileName, content, {\n          createFolders: true\n        });\n      });\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(data) {\n      this.data = data;\n      return this;\n    }\n  }, {\n    key: \"getZip\",\n    value: function getZip() {\n      return this.zip;\n    }\n  }, {\n    key: \"createTemplateClass\",\n    value: function createTemplateClass(path) {\n      var content = this.zip.files[path].asText();\n      return this.createTemplateClassFromContent(content, path);\n    }\n  }, {\n    key: \"createTemplateClassFromContent\",\n    value: function createTemplateClassFromContent(content, filePath) {\n      var _this8 = this;\n\n      var xmltOptions = {\n        filePath: filePath,\n        contentType: this.filesContentTypes[filePath]\n      };\n      Object.keys(defaults).concat([\"filesContentTypes\", \"fileTypeConfig\", \"modules\"]).forEach(function (key) {\n        xmltOptions[key] = _this8[key];\n      });\n      return new Docxtemplater.XmlTemplater(content, xmltOptions);\n    }\n  }, {\n    key: \"getFullText\",\n    value: function getFullText(path) {\n      return this.createTemplateClass(path || this.fileTypeConfig.textPath(this)).getFullText();\n    }\n  }, {\n    key: \"getTemplatedFiles\",\n    value: function getTemplatedFiles() {\n      var _this9 = this;\n\n      this.templatedFiles = this.fileTypeConfig.getTemplatedFiles(this.zip);\n      this.targets.forEach(function (target) {\n        _this9.templatedFiles.push(target);\n      });\n      return this.templatedFiles;\n    }\n  }]);\n\n  return Docxtemplater;\n}();\n\nfunction verifyErrors(doc) {\n  var compiled = doc.compiled;\n  var allErrors = [];\n  Object.keys(compiled).forEach(function (name) {\n    var templatePart = compiled[name];\n    allErrors = concatArrays([allErrors, templatePart.allErrors]);\n  });\n  doc.errors = allErrors;\n\n  if (allErrors.length !== 0) {\n    throwMultiError(allErrors);\n  }\n}\n\nDocxtemplater.DocUtils = DocUtils;\nDocxtemplater.Errors = __webpack_require__(/*! ./errors */ \"./es6/errors.js\");\nDocxtemplater.XmlTemplater = __webpack_require__(/*! ./xml-templater */ \"./es6/xml-templater.js\");\nDocxtemplater.FileTypeConfig = __webpack_require__(/*! ./file-type-config */ \"./es6/file-type-config.js\");\nDocxtemplater.XmlMatcher = __webpack_require__(/*! ./xml-matcher */ \"./es6/xml-matcher.js\");\nmodule.exports = Docxtemplater;\n\n//# sourceURL=webpack://docxtemplater/./es6/docxtemplater.js?");

/***/ }),

/***/ "./es6/errors.js":
/*!***********************!*\
  !*** ./es6/errors.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar _require = __webpack_require__(/*! ./utils */ \"./es6/utils.js\"),\n    last = _require.last,\n    first = _require.first;\n\nfunction XTError(message) {\n  this.name = \"GenericError\";\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\n\nXTError.prototype = Error.prototype;\n\nfunction XTTemplateError(message) {\n  this.name = \"TemplateError\";\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\n\nXTTemplateError.prototype = new XTError();\n\nfunction XTRenderingError(message) {\n  this.name = \"RenderingError\";\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\n\nXTRenderingError.prototype = new XTError();\n\nfunction XTScopeParserError(message) {\n  this.name = \"ScopeParserError\";\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\n\nXTScopeParserError.prototype = new XTError();\n\nfunction XTInternalError(message) {\n  this.name = \"InternalError\";\n  this.properties = {\n    explanation: \"InternalError\"\n  };\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\n\nXTInternalError.prototype = new XTError();\n\nfunction XTAPIVersionError(message) {\n  this.name = \"APIVersionError\";\n  this.properties = {\n    explanation: \"APIVersionError\"\n  };\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\n\nXTAPIVersionError.prototype = new XTError();\n\nfunction throwApiVersionError(msg, properties) {\n  var err = new XTAPIVersionError(msg);\n  err.properties = _objectSpread({\n    id: \"api_version_error\"\n  }, properties);\n  throw err;\n}\n\nfunction throwMultiError(errors) {\n  var err = new XTTemplateError(\"Multi error\");\n  err.properties = {\n    errors: errors,\n    id: \"multi_error\",\n    explanation: \"The template has multiple errors\"\n  };\n  throw err;\n}\n\nfunction getUnopenedTagException(options) {\n  var err = new XTTemplateError(\"Unopened tag\");\n  err.properties = {\n    xtag: last(options.xtag.split(\" \")),\n    id: \"unopened_tag\",\n    context: options.xtag,\n    offset: options.offset,\n    lIndex: options.lIndex,\n    explanation: \"The tag beginning with \\\"\".concat(options.xtag.substr(0, 10), \"\\\" is unopened\")\n  };\n  return err;\n}\n\nfunction getDuplicateOpenTagException(options) {\n  var err = new XTTemplateError(\"Duplicate open tag, expected one open tag\");\n  err.properties = {\n    xtag: first(options.xtag.split(\" \")),\n    id: \"duplicate_open_tag\",\n    context: options.xtag,\n    offset: options.offset,\n    lIndex: options.lIndex,\n    explanation: \"The tag beginning with \\\"\".concat(options.xtag.substr(0, 10), \"\\\" has duplicate open tags\")\n  };\n  return err;\n}\n\nfunction getDuplicateCloseTagException(options) {\n  var err = new XTTemplateError(\"Duplicate close tag, expected one close tag\");\n  err.properties = {\n    xtag: first(options.xtag.split(\" \")),\n    id: \"duplicate_close_tag\",\n    context: options.xtag,\n    offset: options.offset,\n    lIndex: options.lIndex,\n    explanation: \"The tag ending with \\\"\".concat(options.xtag.substr(0, 10), \"\\\" has duplicate close tags\")\n  };\n  return err;\n}\n\nfunction getUnclosedTagException(options) {\n  var err = new XTTemplateError(\"Unclosed tag\");\n  err.properties = {\n    xtag: first(options.xtag.split(\" \")).substr(1),\n    id: \"unclosed_tag\",\n    context: options.xtag,\n    offset: options.offset,\n    lIndex: options.lIndex,\n    explanation: \"The tag beginning with \\\"\".concat(options.xtag.substr(0, 10), \"\\\" is unclosed\")\n  };\n  return err;\n}\n\nfunction throwXmlTagNotFound(options) {\n  var err = new XTTemplateError(\"No tag \\\"\".concat(options.element, \"\\\" was found at the \").concat(options.position));\n  var part = options.parsed[options.index];\n  err.properties = {\n    id: \"no_xml_tag_found_at_\".concat(options.position),\n    explanation: \"No tag \\\"\".concat(options.element, \"\\\" was found at the \").concat(options.position),\n    offset: part.offset,\n    part: part,\n    parsed: options.parsed,\n    index: options.index,\n    element: options.element\n  };\n  throw err;\n}\n\nfunction getCorruptCharactersException(_ref) {\n  var tag = _ref.tag,\n      value = _ref.value,\n      offset = _ref.offset;\n  var err = new XTRenderingError(\"There are some XML corrupt characters\");\n  err.properties = {\n    id: \"invalid_xml_characters\",\n    xtag: tag,\n    value: value,\n    offset: offset,\n    explanation: \"There are some corrupt characters for the field ${tag}\"\n  };\n  return err;\n}\n\nfunction throwContentMustBeString(type) {\n  var err = new XTInternalError(\"Content must be a string\");\n  err.properties.id = \"xmltemplater_content_must_be_string\";\n  err.properties.type = type;\n  throw err;\n}\n\nfunction throwExpandNotFound(options) {\n  var _options$part = options.part,\n      value = _options$part.value,\n      offset = _options$part.offset,\n      _options$id = options.id,\n      id = _options$id === void 0 ? \"raw_tag_outerxml_invalid\" : _options$id,\n      _options$message = options.message,\n      message = _options$message === void 0 ? \"Raw tag not in paragraph\" : _options$message;\n  var part = options.part;\n  var _options$explanation = options.explanation,\n      explanation = _options$explanation === void 0 ? \"The tag \\\"\".concat(value, \"\\\" is not inside a paragraph\") : _options$explanation;\n\n  if (typeof explanation === \"function\") {\n    explanation = explanation(part);\n  }\n\n  var err = new XTTemplateError(message);\n  err.properties = {\n    id: id,\n    explanation: explanation,\n    rootError: options.rootError,\n    xtag: value,\n    offset: offset,\n    postparsed: options.postparsed,\n    expandTo: options.expandTo,\n    index: options.index\n  };\n  throw err;\n}\n\nfunction throwRawTagShouldBeOnlyTextInParagraph(options) {\n  var err = new XTTemplateError(\"Raw tag should be the only text in paragraph\");\n  var tag = options.part.value;\n  err.properties = {\n    id: \"raw_xml_tag_should_be_only_text_in_paragraph\",\n    explanation: \"The raw tag \\\"\".concat(tag, \"\\\" should be the only text in this paragraph. This means that this tag should not be surrounded by any text or spaces.\"),\n    xtag: tag,\n    offset: options.part.offset,\n    paragraphParts: options.paragraphParts\n  };\n  throw err;\n}\n\nfunction getUnmatchedLoopException(part) {\n  var location = part.location,\n      offset = part.offset;\n  var t = location === \"start\" ? \"unclosed\" : \"unopened\";\n  var T = location === \"start\" ? \"Unclosed\" : \"Unopened\";\n  var err = new XTTemplateError(\"\".concat(T, \" loop\"));\n  var tag = part.value;\n  err.properties = {\n    id: \"\".concat(t, \"_loop\"),\n    explanation: \"The loop with tag \\\"\".concat(tag, \"\\\" is \").concat(t),\n    xtag: tag,\n    offset: offset\n  };\n  return err;\n}\n\nfunction getUnbalancedLoopException(pair, lastPair) {\n  var err = new XTTemplateError(\"Unbalanced loop tag\");\n  var lastL = lastPair[0].part.value;\n  var lastR = lastPair[1].part.value;\n  var l = pair[0].part.value;\n  var r = pair[1].part.value;\n  err.properties = {\n    id: \"unbalanced_loop_tags\",\n    explanation: \"Unbalanced loop tags {#\".concat(lastL, \"}{/\").concat(lastR, \"}{#\").concat(l, \"}{/\").concat(r, \"}\"),\n    offset: [lastPair[0].part.offset, pair[1].part.offset],\n    lastPair: {\n      left: lastPair[0].part.value,\n      right: lastPair[1].part.value\n    },\n    pair: {\n      left: pair[0].part.value,\n      right: pair[1].part.value\n    }\n  };\n  return err;\n}\n\nfunction getClosingTagNotMatchOpeningTag(_ref2) {\n  var tags = _ref2.tags;\n  var err = new XTTemplateError(\"Closing tag does not match opening tag\");\n  err.properties = {\n    id: \"closing_tag_does_not_match_opening_tag\",\n    explanation: \"The tag \\\"\".concat(tags[0].value, \"\\\" is closed by the tag \\\"\").concat(tags[1].value, \"\\\"\"),\n    openingtag: first(tags).value,\n    offset: [first(tags).offset, last(tags).offset],\n    closingtag: last(tags).value\n  };\n  return err;\n}\n\nfunction getScopeCompilationError(_ref3) {\n  var tag = _ref3.tag,\n      rootError = _ref3.rootError,\n      offset = _ref3.offset;\n  var err = new XTScopeParserError(\"Scope parser compilation failed\");\n  err.properties = {\n    id: \"scopeparser_compilation_failed\",\n    offset: offset,\n    tag: tag,\n    explanation: \"The scope parser for the tag \\\"\".concat(tag, \"\\\" failed to compile\"),\n    rootError: rootError\n  };\n  return err;\n}\n\nfunction getScopeParserExecutionError(_ref4) {\n  var tag = _ref4.tag,\n      scope = _ref4.scope,\n      error = _ref4.error,\n      offset = _ref4.offset;\n  var err = new XTScopeParserError(\"Scope parser execution failed\");\n  err.properties = {\n    id: \"scopeparser_execution_failed\",\n    explanation: \"The scope parser for the tag \".concat(tag, \" failed to execute\"),\n    scope: scope,\n    offset: offset,\n    tag: tag,\n    rootError: error\n  };\n  return err;\n}\n\nfunction getLoopPositionProducesInvalidXMLError(_ref5) {\n  var tag = _ref5.tag,\n      offset = _ref5.offset;\n  var err = new XTTemplateError(\"The position of the loop tags \\\"\".concat(tag, \"\\\" would produce invalid XML\"));\n  err.properties = {\n    tag: tag,\n    id: \"loop_position_invalid\",\n    explanation: \"The tags \\\"\".concat(tag, \"\\\" are misplaced in the document, for example one of them is in a table and the other one outside the table\"),\n    offset: offset\n  };\n  return err;\n}\n\nfunction throwUnimplementedTagType(part, index) {\n  var errorMsg = \"Unimplemented tag type \\\"\".concat(part.type, \"\\\"\");\n\n  if (part.module) {\n    errorMsg += \" \\\"\".concat(part.module, \"\\\"\");\n  }\n\n  var err = new XTTemplateError(errorMsg);\n  err.properties = {\n    part: part,\n    index: index,\n    id: \"unimplemented_tag_type\"\n  };\n  throw err;\n}\n\nfunction throwMalformedXml(part) {\n  var err = new XTInternalError(\"Malformed xml\");\n  err.properties = {\n    part: part,\n    id: \"malformed_xml\"\n  };\n  throw err;\n}\n\nfunction throwLocationInvalid(part) {\n  throw new XTInternalError(\"Location should be one of \\\"start\\\" or \\\"end\\\" (given : \".concat(part.location, \")\"));\n}\n\nfunction throwResolveBeforeCompile() {\n  var err = new XTInternalError(\"You must run `.compile()` before running `.resolveData()`\");\n  err.properties = {\n    id: \"resolve_before_compile\"\n  };\n  throw err;\n}\n\nfunction throwRenderInvalidTemplate() {\n  var err = new XTInternalError(\"You should not call .render on a document that had compilation errors\");\n  err.properties = {\n    id: \"render_on_invalid_template\"\n  };\n  throw err;\n}\n\nfunction throwFileTypeNotIdentified() {\n  var err = new XTInternalError(\"The filetype for this file could not be identified, is this file corrupted ?\");\n  err.properties = {\n    id: \"filetype_not_identified\"\n  };\n  throw err;\n}\n\nfunction throwXmlInvalid(content, offset) {\n  var err = new XTTemplateError(\"An XML file has invalid xml\");\n  err.properties = {\n    id: \"file_has_invalid_xml\",\n    content: content,\n    offset: offset,\n    explanation: \"The docx contains invalid XML, it is most likely corrupt\"\n  };\n  throw err;\n}\n\nfunction throwFileTypeNotHandled(fileType) {\n  var err = new XTInternalError(\"The filetype \\\"\".concat(fileType, \"\\\" is not handled by docxtemplater\"));\n  err.properties = {\n    id: \"filetype_not_handled\",\n    explanation: \"The file you are trying to generate is of type \\\"\".concat(fileType, \"\\\", but only docx and pptx formats are handled\"),\n    fileType: fileType\n  };\n  throw err;\n}\n\nmodule.exports = {\n  XTError: XTError,\n  XTTemplateError: XTTemplateError,\n  XTInternalError: XTInternalError,\n  XTScopeParserError: XTScopeParserError,\n  XTAPIVersionError: XTAPIVersionError,\n  // Remove this alias in v4\n  RenderingError: XTRenderingError,\n  XTRenderingError: XTRenderingError,\n  getClosingTagNotMatchOpeningTag: getClosingTagNotMatchOpeningTag,\n  getLoopPositionProducesInvalidXMLError: getLoopPositionProducesInvalidXMLError,\n  getScopeCompilationError: getScopeCompilationError,\n  getScopeParserExecutionError: getScopeParserExecutionError,\n  getUnclosedTagException: getUnclosedTagException,\n  getUnopenedTagException: getUnopenedTagException,\n  getUnmatchedLoopException: getUnmatchedLoopException,\n  getDuplicateCloseTagException: getDuplicateCloseTagException,\n  getDuplicateOpenTagException: getDuplicateOpenTagException,\n  getCorruptCharactersException: getCorruptCharactersException,\n  getUnbalancedLoopException: getUnbalancedLoopException,\n  throwApiVersionError: throwApiVersionError,\n  throwContentMustBeString: throwContentMustBeString,\n  throwFileTypeNotHandled: throwFileTypeNotHandled,\n  throwFileTypeNotIdentified: throwFileTypeNotIdentified,\n  throwLocationInvalid: throwLocationInvalid,\n  throwMalformedXml: throwMalformedXml,\n  throwMultiError: throwMultiError,\n  throwExpandNotFound: throwExpandNotFound,\n  throwRawTagShouldBeOnlyTextInParagraph: throwRawTagShouldBeOnlyTextInParagraph,\n  throwUnimplementedTagType: throwUnimplementedTagType,\n  throwXmlTagNotFound: throwXmlTagNotFound,\n  throwXmlInvalid: throwXmlInvalid,\n  throwResolveBeforeCompile: throwResolveBeforeCompile,\n  throwRenderInvalidTemplate: throwRenderInvalidTemplate\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/errors.js?");

/***/ }),

/***/ "./es6/file-type-config.js":
/*!*********************************!*\
  !*** ./es6/file-type-config.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar loopModule = __webpack_require__(/*! ./modules/loop */ \"./es6/modules/loop.js\");\n\nvar spacePreserveModule = __webpack_require__(/*! ./modules/space-preserve */ \"./es6/modules/space-preserve.js\");\n\nvar rawXmlModule = __webpack_require__(/*! ./modules/rawxml */ \"./es6/modules/rawxml.js\");\n\nvar expandPairTrait = __webpack_require__(/*! ./modules/expand-pair-trait */ \"./es6/modules/expand-pair-trait.js\");\n\nvar render = __webpack_require__(/*! ./modules/render */ \"./es6/modules/render.js\");\n\nfunction PptXFileTypeConfig() {\n  return {\n    getTemplatedFiles: function getTemplatedFiles(zip) {\n      var slideTemplates = zip.file(/ppt\\/(slideMasters)\\/(slideMaster)\\d+\\.xml/).map(function (file) {\n        return file.name;\n      });\n      return slideTemplates.concat([\"ppt/presentation.xml\", \"docProps/app.xml\", \"docProps/core.xml\"]);\n    },\n    textPath: function textPath() {\n      return \"ppt/slides/slide1.xml\";\n    },\n    tagsXmlTextArray: [\"Company\", \"HyperlinkBase\", \"Manager\", \"cp:category\", \"cp:keywords\", \"dc:creator\", \"dc:description\", \"dc:subject\", \"dc:title\", \"a:t\", \"m:t\", \"vt:lpstr\"],\n    tagsXmlLexedArray: [\"p:sp\", \"a:tc\", \"a:tr\", \"a:table\", \"a:p\", \"a:r\", \"a:rPr\", \"p:txBody\", \"a:txBody\"],\n    expandTags: [{\n      contains: \"a:tc\",\n      expand: \"a:tr\"\n    }],\n    onParagraphLoop: [{\n      contains: \"a:p\",\n      expand: \"a:p\",\n      onlyTextInTag: true\n    }],\n    tagRawXml: \"p:sp\",\n    tagTextXml: \"a:t\",\n    baseModules: [loopModule, expandPairTrait, rawXmlModule, render],\n    tagShouldContain: [{\n      tag: \"p:txBody\",\n      shouldContain: [\"a:p\"],\n      value: \"<a:p></a:p>\"\n    }, {\n      tag: \"a:txBody\",\n      shouldContain: [\"a:p\"],\n      value: \"<a:p></a:p>\"\n    }]\n  };\n}\n\nfunction DocXFileTypeConfig() {\n  return {\n    getTemplatedFiles: function getTemplatedFiles(zip) {\n      var baseTags = [\"docProps/core.xml\", \"docProps/app.xml\", \"word/settings.xml\"];\n      var headerFooters = zip.file(/word\\/(header|footer)\\d+\\.xml/).map(function (file) {\n        return file.name;\n      });\n      return headerFooters.concat(baseTags);\n    },\n    textPath: function textPath(doc) {\n      return doc.targets[0];\n    },\n    tagsXmlTextArray: [\"Company\", \"HyperlinkBase\", \"Manager\", \"cp:category\", \"cp:keywords\", \"dc:creator\", \"dc:description\", \"dc:subject\", \"dc:title\", \"w:t\", \"m:t\", \"vt:lpstr\"],\n    tagsXmlLexedArray: [\"w:proofState\", \"w:tc\", \"w:tr\", \"w:table\", \"w:p\", \"w:r\", \"w:br\", \"w:rPr\", \"w:pPr\", \"w:spacing\", \"w:sdtContent\", \"w:sectPr\", \"w:headerReference\", \"w:footerReference\"],\n    expandTags: [{\n      contains: \"w:tc\",\n      expand: \"w:tr\"\n    }],\n    onParagraphLoop: [{\n      contains: \"w:p\",\n      expand: \"w:p\",\n      onlyTextInTag: true\n    }],\n    tagRawXml: \"w:p\",\n    tagTextXml: \"w:t\",\n    baseModules: [loopModule, spacePreserveModule, expandPairTrait, rawXmlModule, render],\n    tagShouldContain: [{\n      tag: \"w:tc\",\n      shouldContain: [\"w:p\"],\n      value: \"<w:p></w:p>\"\n    }, {\n      tag: \"w:sdtContent\",\n      shouldContain: [\"w:p\", \"w:r\"],\n      value: \"<w:p></w:p>\"\n    }]\n  };\n}\n\nmodule.exports = {\n  docx: DocXFileTypeConfig,\n  pptx: PptXFileTypeConfig\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/file-type-config.js?");

/***/ }),

/***/ "./es6/filetypes.js":
/*!**************************!*\
  !*** ./es6/filetypes.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var docxContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml\";\nvar docxmContentType = \"application/vnd.ms-word.document.macroEnabled.main+xml\";\nvar pptxContentType = \"application/vnd.openxmlformats-officedocument.presentationml.slide+xml\";\nvar dotxContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml\";\nvar dotmContentType = \"application/vnd.ms-word.template.macroEnabledTemplate.main+xml\";\nvar filetypes = {\n  docx: [docxContentType, docxmContentType, dotxContentType, dotmContentType],\n  pptx: [pptxContentType]\n};\nmodule.exports = filetypes;\n\n//# sourceURL=webpack://docxtemplater/./es6/filetypes.js?");

/***/ }),

/***/ "./es6/join-uncorrupt.js":
/*!*******************************!*\
  !*** ./es6/join-uncorrupt.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _require = __webpack_require__(/*! ./doc-utils */ \"./es6/doc-utils.js\"),\n    endsWith = _require.endsWith,\n    startsWith = _require.startsWith;\n\nvar filetypes = __webpack_require__(/*! ./filetypes */ \"./es6/filetypes.js\");\n\nfunction addEmptyParagraphAfterTable(parts) {\n  var beforeSectPr = false;\n\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var part = parts[i];\n\n    if (startsWith(part, \"<w:sectPr\")) {\n      beforeSectPr = true;\n    }\n\n    if (beforeSectPr) {\n      var trimmed = part.trim();\n\n      if (endsWith(trimmed, \"</w:tbl>\")) {\n        parts.splice(i + 1, 0, \"<w:p><w:r><w:t></w:t></w:r></w:p>\");\n        return parts;\n      }\n\n      if (endsWith(trimmed, \"</w:p>\")) {\n        return parts;\n      }\n    }\n  }\n\n  return parts;\n}\n\nfunction joinUncorrupt(parts, options) {\n  var contains = options.fileTypeConfig.tagShouldContain || []; // Before doing this \"uncorruption\" method here, this was done with the `part.emptyValue` trick, however, there were some corruptions that were not handled, for example with a template like this :\n  //\n  // ------------------------------------------------\n  // | {-w:p falsy}My para{/falsy}   |              |\n  // | {-w:p falsy}My para{/falsy}   |              |\n  // ------------------------------------------------\n\n  var collecting = \"\";\n  var currentlyCollecting = -1;\n\n  if (!options.basePart && filetypes.docx.indexOf(options.contentType) !== -1) {\n    parts = addEmptyParagraphAfterTable(parts);\n  }\n\n  return parts.reduce(function (full, part) {\n    for (var i = 0, len = contains.length; i < len; i++) {\n      var _contains$i = contains[i],\n          tag = _contains$i.tag,\n          shouldContain = _contains$i.shouldContain,\n          value = _contains$i.value;\n      var startTagRegex = new RegExp(\"^(<(\".concat(tag, \")[^>]*>)$\"), \"g\");\n\n      if (currentlyCollecting === i) {\n        if (part === \"</\".concat(tag, \">\")) {\n          currentlyCollecting = -1;\n          return full + collecting + value + part;\n        }\n\n        collecting += part;\n\n        for (var j = 0, len2 = shouldContain.length; j < len2; j++) {\n          var sc = shouldContain[j];\n\n          if (part.indexOf(\"<\".concat(sc, \" \")) !== -1 || part.indexOf(\"<\".concat(sc, \">\")) !== -1) {\n            currentlyCollecting = -1;\n            return full + collecting;\n          }\n        }\n\n        return full;\n      }\n\n      if (currentlyCollecting === -1 && startTagRegex.test(part)) {\n        if (part[part.length - 2] === \"/\") {\n          return full;\n        }\n\n        currentlyCollecting = i;\n        collecting = part;\n        return full;\n      }\n    }\n\n    return full + part;\n  }, \"\");\n}\n\nmodule.exports = joinUncorrupt;\n\n//# sourceURL=webpack://docxtemplater/./es6/join-uncorrupt.js?");

/***/ }),

/***/ "./es6/lexer.js":
/*!**********************!*\
  !*** ./es6/lexer.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar _require = __webpack_require__(/*! ./errors */ \"./es6/errors.js\"),\n    getUnclosedTagException = _require.getUnclosedTagException,\n    getUnopenedTagException = _require.getUnopenedTagException,\n    getDuplicateOpenTagException = _require.getDuplicateOpenTagException,\n    getDuplicateCloseTagException = _require.getDuplicateCloseTagException,\n    throwMalformedXml = _require.throwMalformedXml,\n    throwXmlInvalid = _require.throwXmlInvalid;\n\nvar _require2 = __webpack_require__(/*! ./doc-utils */ \"./es6/doc-utils.js\"),\n    concatArrays = _require2.concatArrays,\n    isTextStart = _require2.isTextStart,\n    isTextEnd = _require2.isTextEnd;\n\nvar NONE = -2;\nvar EQUAL = 0;\nvar START = -1;\nvar END = 1;\n\nfunction inRange(range, match) {\n  return range[0] <= match.offset && match.offset < range[1];\n}\n\nfunction updateInTextTag(part, inTextTag) {\n  if (isTextStart(part)) {\n    if (inTextTag) {\n      throwMalformedXml(part);\n    }\n\n    return true;\n  }\n\n  if (isTextEnd(part)) {\n    if (!inTextTag) {\n      throwMalformedXml(part);\n    }\n\n    return false;\n  }\n\n  return inTextTag;\n}\n\nfunction getTag(tag) {\n  var position = \"\";\n  var start = 1;\n  var end = tag.indexOf(\" \");\n\n  if (tag[tag.length - 2] === \"/\") {\n    position = \"selfclosing\";\n\n    if (end === -1) {\n      end = tag.length - 2;\n    }\n  } else if (tag[1] === \"/\") {\n    start = 2;\n    position = \"end\";\n\n    if (end === -1) {\n      end = tag.length - 1;\n    }\n  } else {\n    position = \"start\";\n\n    if (end === -1) {\n      end = tag.length - 1;\n    }\n  }\n\n  return {\n    tag: tag.slice(start, end),\n    position: position\n  };\n}\n\nfunction tagMatcher(content, textMatchArray, othersMatchArray) {\n  var cursor = 0;\n  var contentLength = content.length;\n  var allMatches = concatArrays([textMatchArray.map(function (tag) {\n    return {\n      tag: tag,\n      text: true\n    };\n  }), othersMatchArray.map(function (tag) {\n    return {\n      tag: tag,\n      text: false\n    };\n  })]).reduce(function (allMatches, t) {\n    allMatches[t.tag] = t.text;\n    return allMatches;\n  }, {});\n  var totalMatches = [];\n\n  while (cursor < contentLength) {\n    cursor = content.indexOf(\"<\", cursor);\n\n    if (cursor === -1) {\n      break;\n    }\n\n    var offset = cursor;\n    var nextOpening = content.indexOf(\"<\", cursor + 1);\n    cursor = content.indexOf(\">\", cursor);\n\n    if (cursor === -1 || nextOpening !== -1 && cursor > nextOpening) {\n      throwXmlInvalid(content, offset);\n    }\n\n    var tagText = content.slice(offset, cursor + 1);\n\n    var _getTag = getTag(tagText),\n        tag = _getTag.tag,\n        position = _getTag.position;\n\n    var text = allMatches[tag];\n\n    if (text == null) {\n      continue;\n    }\n\n    totalMatches.push({\n      type: \"tag\",\n      position: position,\n      text: text,\n      offset: offset,\n      value: tagText,\n      tag: tag\n    });\n  }\n\n  return totalMatches;\n}\n\nfunction getDelimiterErrors(delimiterMatches, fullText, ranges) {\n  if (delimiterMatches.length === 0) {\n    return [];\n  }\n\n  var errors = [];\n  var inDelimiter = false;\n  var lastDelimiterMatch = {\n    offset: 0\n  };\n  var xtag;\n  var rangeIndex = 0;\n  delimiterMatches.forEach(function (delimiterMatch) {\n    while (ranges[rangeIndex + 1]) {\n      if (ranges[rangeIndex + 1].offset > delimiterMatch.offset) {\n        break;\n      }\n\n      rangeIndex++;\n    }\n\n    xtag = fullText.substr(lastDelimiterMatch.offset, delimiterMatch.offset - lastDelimiterMatch.offset);\n\n    if (delimiterMatch.position === \"start\" && inDelimiter || delimiterMatch.position === \"end\" && !inDelimiter) {\n      if (delimiterMatch.position === \"start\") {\n        if (lastDelimiterMatch.offset + lastDelimiterMatch.length === delimiterMatch.offset) {\n          xtag = fullText.substr(lastDelimiterMatch.offset, delimiterMatch.offset - lastDelimiterMatch.offset + lastDelimiterMatch.length + 4);\n          errors.push(getDuplicateOpenTagException({\n            xtag: xtag,\n            offset: lastDelimiterMatch.offset\n          }));\n        } else {\n          errors.push(getUnclosedTagException({\n            xtag: xtag,\n            offset: lastDelimiterMatch.offset\n          }));\n        }\n\n        delimiterMatch.error = true;\n      } else {\n        if (lastDelimiterMatch.offset + lastDelimiterMatch.length === delimiterMatch.offset) {\n          xtag = fullText.substr(lastDelimiterMatch.offset - 4, delimiterMatch.offset - lastDelimiterMatch.offset + 4 + lastDelimiterMatch.length);\n          errors.push(getDuplicateCloseTagException({\n            xtag: xtag,\n            offset: lastDelimiterMatch.offset\n          }));\n        } else {\n          errors.push(getUnopenedTagException({\n            xtag: xtag,\n            offset: delimiterMatch.offset\n          }));\n        }\n\n        delimiterMatch.error = true;\n      }\n    } else {\n      inDelimiter = !inDelimiter;\n    }\n\n    lastDelimiterMatch = delimiterMatch;\n  });\n  var delimiterMatch = {\n    offset: fullText.length\n  };\n  xtag = fullText.substr(lastDelimiterMatch.offset, delimiterMatch.offset - lastDelimiterMatch.offset);\n\n  if (inDelimiter) {\n    errors.push(getUnclosedTagException({\n      xtag: xtag,\n      offset: lastDelimiterMatch.offset\n    }));\n    delimiterMatch.error = true;\n  }\n\n  return errors;\n}\n\nfunction compareOffsets(startOffset, endOffset) {\n  if (startOffset === -1 && endOffset === -1) {\n    return NONE;\n  }\n\n  if (startOffset === endOffset) {\n    return EQUAL;\n  }\n\n  if (startOffset === -1 || endOffset === -1) {\n    return endOffset < startOffset ? START : END;\n  }\n\n  return startOffset < endOffset ? START : END;\n}\n\nfunction splitDelimiters(inside) {\n  var newDelimiters = inside.split(\" \");\n\n  if (newDelimiters.length !== 2) {\n    throw new Error(\"New Delimiters cannot be parsed\");\n  }\n\n  var _newDelimiters = _slicedToArray(newDelimiters, 2),\n      start = _newDelimiters[0],\n      end = _newDelimiters[1];\n\n  if (start.length === 0 || end.length === 0) {\n    throw new Error(\"New Delimiters cannot be parsed\");\n  }\n\n  return [start, end];\n}\n\nfunction getAllIndexes(fullText, delimiters) {\n  var indexes = [];\n  var start = delimiters.start,\n      end = delimiters.end;\n  var offset = -1;\n  var insideTag = false;\n\n  while (true) {\n    var startOffset = fullText.indexOf(start, offset + 1);\n    var endOffset = fullText.indexOf(end, offset + 1);\n    var position = null;\n    var len = void 0;\n    var compareResult = compareOffsets(startOffset, endOffset);\n\n    if (compareResult === NONE) {\n      return indexes;\n    }\n\n    if (compareResult === EQUAL) {\n      if (!insideTag) {\n        compareResult = START;\n      } else {\n        compareResult = END;\n      }\n    }\n\n    if (compareResult === END) {\n      insideTag = false;\n      offset = endOffset;\n      position = \"end\";\n      len = end.length;\n    }\n\n    if (compareResult === START) {\n      insideTag = true;\n      offset = startOffset;\n      position = \"start\";\n      len = start.length;\n    }\n\n    if (position === \"start\" && fullText[offset + start.length] === \"=\") {\n      indexes.push({\n        offset: startOffset,\n        position: \"start\",\n        length: start.length,\n        changedelimiter: true\n      });\n      var nextEqual = fullText.indexOf(\"=\", offset + start.length + 1);\n\n      var _endOffset = fullText.indexOf(end, nextEqual + 1);\n\n      indexes.push({\n        offset: _endOffset,\n        position: \"end\",\n        length: end.length,\n        changedelimiter: true\n      });\n\n      var _insideTag = fullText.substr(offset + start.length + 1, nextEqual - offset - start.length - 1);\n\n      var _splitDelimiters = splitDelimiters(_insideTag);\n\n      var _splitDelimiters2 = _slicedToArray(_splitDelimiters, 2);\n\n      start = _splitDelimiters2[0];\n      end = _splitDelimiters2[1];\n      offset = _endOffset;\n      continue;\n    }\n\n    indexes.push({\n      offset: offset,\n      position: position,\n      length: len\n    });\n  }\n}\n\nfunction parseDelimiters(innerContentParts, delimiters) {\n  var full = innerContentParts.map(function (p) {\n    return p.value;\n  }).join(\"\");\n  var delimiterMatches = getAllIndexes(full, delimiters);\n  var offset = 0;\n  var ranges = innerContentParts.map(function (part) {\n    offset += part.value.length;\n    return {\n      offset: offset - part.value.length,\n      lIndex: part.lIndex\n    };\n  });\n  var errors = getDelimiterErrors(delimiterMatches, full, ranges);\n  var cutNext = 0;\n  var delimiterIndex = 0;\n  var parsed = ranges.map(function (p, i) {\n    var offset = p.offset;\n    var range = [offset, offset + innerContentParts[i].value.length];\n    var partContent = innerContentParts[i].value;\n    var delimitersInOffset = [];\n\n    while (delimiterIndex < delimiterMatches.length && inRange(range, delimiterMatches[delimiterIndex])) {\n      delimitersInOffset.push(delimiterMatches[delimiterIndex]);\n      delimiterIndex++;\n    }\n\n    var parts = [];\n    var cursor = 0;\n\n    if (cutNext > 0) {\n      cursor = cutNext;\n      cutNext = 0;\n    }\n\n    var insideDelimiterChange;\n    delimitersInOffset.forEach(function (delimiterInOffset) {\n      var value = partContent.substr(cursor, delimiterInOffset.offset - offset - cursor);\n\n      if (value.length > 0) {\n        if (insideDelimiterChange) {\n          if (delimiterInOffset.changedelimiter) {\n            cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n            insideDelimiterChange = delimiterInOffset.position === \"start\";\n          }\n\n          return;\n        }\n\n        parts.push({\n          type: \"content\",\n          value: value,\n          offset: cursor + offset\n        });\n        cursor += value.length;\n      }\n\n      var delimiterPart = {\n        type: \"delimiter\",\n        position: delimiterInOffset.position,\n        offset: cursor + offset\n      };\n\n      if (delimiterInOffset.error) {\n        delimiterPart.error = delimiterInOffset.error;\n      }\n\n      if (delimiterInOffset.changedelimiter) {\n        insideDelimiterChange = delimiterInOffset.position === \"start\";\n        cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n        return;\n      }\n\n      parts.push(delimiterPart);\n      cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n    });\n    cutNext = cursor - partContent.length;\n    var value = partContent.substr(cursor);\n\n    if (value.length > 0) {\n      parts.push({\n        type: \"content\",\n        value: value,\n        offset: offset\n      });\n    }\n\n    return parts;\n  }, this);\n  return {\n    parsed: parsed,\n    errors: errors\n  };\n}\n\nfunction getContentParts(xmlparsed) {\n  var inTextTag = false;\n  var innerContentParts = [];\n  xmlparsed.forEach(function (part) {\n    inTextTag = updateInTextTag(part, inTextTag);\n\n    if (inTextTag && part.type === \"content\") {\n      innerContentParts.push(part);\n    }\n  });\n  return innerContentParts;\n}\n\nmodule.exports = {\n  parseDelimiters: parseDelimiters,\n  parse: function parse(xmlparsed, delimiters) {\n    var inTextTag = false;\n\n    var _parseDelimiters = parseDelimiters(getContentParts(xmlparsed), delimiters),\n        delimiterParsed = _parseDelimiters.parsed,\n        errors = _parseDelimiters.errors;\n\n    var lexed = [];\n    var index = 0;\n    xmlparsed.forEach(function (part) {\n      inTextTag = updateInTextTag(part, inTextTag);\n\n      if (part.type === \"content\") {\n        part.position = inTextTag ? \"insidetag\" : \"outsidetag\";\n      }\n\n      if (inTextTag && part.type === \"content\") {\n        Array.prototype.push.apply(lexed, delimiterParsed[index].map(function (p) {\n          if (p.type === \"content\") {\n            p.position = \"insidetag\";\n          }\n\n          return p;\n        }));\n        index++;\n      } else {\n        lexed.push(part);\n      }\n    });\n    lexed = lexed.map(function (p, i) {\n      p.lIndex = i;\n      return p;\n    });\n    return {\n      errors: errors,\n      lexed: lexed\n    };\n  },\n  xmlparse: function xmlparse(content, xmltags) {\n    var matches = tagMatcher(content, xmltags.text, xmltags.other);\n    var cursor = 0;\n    var parsed = matches.reduce(function (parsed, match) {\n      var value = content.substr(cursor, match.offset - cursor);\n\n      if (value.length > 0) {\n        parsed.push({\n          type: \"content\",\n          value: value\n        });\n      }\n\n      cursor = match.offset + match.value.length;\n      delete match.offset;\n\n      if (match.value.length > 0) {\n        parsed.push(match);\n      }\n\n      return parsed;\n    }, []);\n    var value = content.substr(cursor);\n\n    if (value.length > 0) {\n      parsed.push({\n        type: \"content\",\n        value: value\n      });\n    }\n\n    return parsed;\n  }\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/lexer.js?");

/***/ }),

/***/ "./es6/mergesort.js":
/*!**************************!*\
  !*** ./es6/mergesort.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function getMinFromArrays(arrays, state) {\n  var minIndex = -1;\n\n  for (var i = 0, l = arrays.length; i < l; i++) {\n    if (state[i] >= arrays[i].length) {\n      continue;\n    }\n\n    if (minIndex === -1 || arrays[i][state[i]].offset < arrays[minIndex][state[minIndex]].offset) {\n      minIndex = i;\n    }\n  }\n\n  if (minIndex === -1) {\n    throw new Error(\"minIndex negative\");\n  }\n\n  return minIndex;\n}\n\nmodule.exports = function (arrays) {\n  var totalLength = arrays.reduce(function (sum, array) {\n    return sum + array.length;\n  }, 0);\n  arrays = arrays.filter(function (array) {\n    return array.length > 0;\n  });\n  var resultArray = new Array(totalLength);\n  var state = arrays.map(function () {\n    return 0;\n  });\n  var i = 0;\n\n  while (i <= totalLength - 1) {\n    var arrayIndex = getMinFromArrays(arrays, state);\n    resultArray[i] = arrays[arrayIndex][state[arrayIndex]];\n    state[arrayIndex]++;\n    i++;\n  }\n\n  return resultArray;\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/mergesort.js?");

/***/ }),

/***/ "./es6/module-wrapper.js":
/*!*******************************!*\
  !*** ./es6/module-wrapper.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function emptyFun() {}\n\nfunction identity(i) {\n  return i;\n}\n\nmodule.exports = function (module) {\n  var defaults = {\n    set: emptyFun,\n    parse: emptyFun,\n    render: emptyFun,\n    getTraits: emptyFun,\n    getFileType: emptyFun,\n    nullGetter: emptyFun,\n    optionsTransformer: identity,\n    postrender: identity,\n    errorsTransformer: identity,\n    getRenderedMap: identity,\n    preparse: identity,\n    postparse: identity,\n    on: emptyFun,\n    resolve: emptyFun\n  };\n\n  if (Object.keys(defaults).every(function (key) {\n    return !module[key];\n  })) {\n    throw new Error(\"This module cannot be wrapped, because it doesn't define any of the necessary functions\");\n  }\n\n  Object.keys(defaults).forEach(function (key) {\n    module[key] = module[key] || defaults[key];\n  });\n  return module;\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/module-wrapper.js?");

/***/ }),

/***/ "./es6/modules/common.js":
/*!*******************************!*\
  !*** ./es6/modules/common.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar wrapper = __webpack_require__(/*! ../module-wrapper */ \"./es6/module-wrapper.js\");\n\nvar _require = __webpack_require__(/*! ../doc-utils */ \"./es6/doc-utils.js\"),\n    concatArrays = _require.concatArrays;\n\nvar filetypes = __webpack_require__(/*! ../filetypes */ \"./es6/filetypes.js\");\n\nvar Common = /*#__PURE__*/function () {\n  function Common() {\n    _classCallCheck(this, Common);\n\n    this.name = \"Common\";\n  }\n\n  _createClass(Common, [{\n    key: \"set\",\n    value: function set(_ref) {\n      var invertedContentTypes = _ref.invertedContentTypes;\n\n      if (invertedContentTypes) {\n        this.invertedContentTypes = invertedContentTypes;\n      }\n    }\n  }, {\n    key: \"getFileType\",\n    value: function getFileType(_ref2) {\n      var doc = _ref2.doc;\n      var invertedContentTypes = this.invertedContentTypes;\n\n      if (!this.invertedContentTypes) {\n        return;\n      }\n\n      var keys = Object.keys(filetypes);\n\n      for (var i = 0, len = keys.length; i < len; i++) {\n        var ftCandidate = keys[i];\n        var contentTypes = filetypes[ftCandidate];\n\n        for (var j = 0, len2 = contentTypes.length; j < len2; j++) {\n          var ct = contentTypes[j];\n\n          if (invertedContentTypes[ct]) {\n            doc.targets = concatArrays([doc.targets, invertedContentTypes[ct]]);\n            return ftCandidate;\n          }\n        }\n      }\n    }\n  }]);\n\n  return Common;\n}();\n\nmodule.exports = function () {\n  return wrapper(new Common());\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/modules/common.js?");

/***/ }),

/***/ "./es6/modules/expand-pair-trait.js":
/*!******************************************!*\
  !*** ./es6/modules/expand-pair-trait.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var traitName = \"expandPair\";\n\nvar mergeSort = __webpack_require__(/*! ../mergesort */ \"./es6/mergesort.js\");\n\nvar _require = __webpack_require__(/*! ../doc-utils */ \"./es6/doc-utils.js\"),\n    getLeft = _require.getLeft,\n    getRight = _require.getRight;\n\nvar wrapper = __webpack_require__(/*! ../module-wrapper */ \"./es6/module-wrapper.js\");\n\nvar _require2 = __webpack_require__(/*! ../traits */ \"./es6/traits.js\"),\n    getExpandToDefault = _require2.getExpandToDefault;\n\nvar _require3 = __webpack_require__(/*! ../errors */ \"./es6/errors.js\"),\n    getUnmatchedLoopException = _require3.getUnmatchedLoopException,\n    getClosingTagNotMatchOpeningTag = _require3.getClosingTagNotMatchOpeningTag,\n    throwLocationInvalid = _require3.throwLocationInvalid,\n    getUnbalancedLoopException = _require3.getUnbalancedLoopException;\n\nfunction getOpenCountChange(part) {\n  switch (part.location) {\n    case \"start\":\n      return 1;\n\n    case \"end\":\n      return -1;\n\n    default:\n      throwLocationInvalid(part);\n  }\n}\n\nfunction match(start, end) {\n  return start != null && end != null && (start.part.location === \"start\" && end.part.location === \"end\" && start.part.value === end.part.value || end.part.value === \"\");\n}\n\nfunction transformer(traits) {\n  var i = 0;\n  var errors = [];\n\n  while (i < traits.length) {\n    var part = traits[i].part;\n\n    if (part.location === \"end\") {\n      if (i === 0) {\n        traits.splice(0, 1);\n        errors.push(getUnmatchedLoopException(part));\n        return {\n          traits: traits,\n          errors: errors\n        };\n      }\n\n      var endIndex = i;\n      var startIndex = i - 1;\n      var offseter = 1;\n\n      if (match(traits[startIndex], traits[endIndex])) {\n        traits.splice(endIndex, 1);\n        traits.splice(startIndex, 1);\n        return {\n          errors: errors,\n          traits: traits\n        };\n      }\n\n      while (offseter < 50) {\n        var startCandidate = traits[startIndex - offseter];\n        var endCandidate = traits[endIndex + offseter];\n\n        if (match(startCandidate, traits[endIndex])) {\n          traits.splice(endIndex, 1);\n          traits.splice(startIndex - offseter, 1);\n          return {\n            errors: errors,\n            traits: traits\n          };\n        }\n\n        if (match(traits[startIndex], endCandidate)) {\n          traits.splice(endIndex + offseter, 1);\n          traits.splice(startIndex, 1);\n          return {\n            errors: errors,\n            traits: traits\n          };\n        }\n\n        offseter++;\n      }\n\n      errors.push(getClosingTagNotMatchOpeningTag({\n        tags: [traits[startIndex].part, traits[endIndex].part]\n      }));\n      traits.splice(endIndex, 1);\n      traits.splice(startIndex, 1);\n      return {\n        traits: traits,\n        errors: errors\n      };\n    }\n\n    if (traits[i] == null) {\n      break;\n    }\n\n    i++;\n  }\n\n  traits.forEach(function (_ref) {\n    var part = _ref.part;\n    errors.push(getUnmatchedLoopException(part));\n  });\n  return {\n    traits: [],\n    errors: errors\n  };\n}\n\nfunction getPairs(traits) {\n  var levelTraits = {};\n  var errors = [];\n  var pairs = [];\n  var countOpen = 0;\n  var transformedTraits = [];\n\n  for (var i = 0; i < traits.length; i++) {\n    var currentTrait = traits[i];\n    var part = currentTrait.part;\n    var change = getOpenCountChange(currentTrait.part);\n    countOpen += change;\n    var level = void 0;\n\n    if (change === 1) {\n      level = countOpen - 1;\n    } else {\n      level = countOpen;\n    }\n\n    transformedTraits.push({\n      level: level,\n      part: part\n    });\n  }\n\n  while (transformedTraits.length > 0) {\n    var result = transformer(transformedTraits);\n    errors = errors.concat(result.errors);\n    transformedTraits = result.traits;\n  }\n\n  if (errors.length > 0) {\n    return {\n      pairs: pairs,\n      errors: errors\n    };\n  }\n\n  countOpen = 0;\n\n  for (var _i = 0; _i < traits.length; _i++) {\n    var _currentTrait = traits[_i];\n    var _part = _currentTrait.part;\n\n    var _change = getOpenCountChange(_part);\n\n    countOpen += _change;\n\n    if (_change === 1) {\n      levelTraits[countOpen] = _currentTrait;\n    } else {\n      var startTrait = levelTraits[countOpen + 1];\n\n      if (countOpen === 0) {\n        pairs = pairs.concat([[startTrait, _currentTrait]]);\n      }\n    }\n\n    countOpen = countOpen >= 0 ? countOpen : 0;\n  }\n\n  return {\n    pairs: pairs,\n    errors: errors\n  };\n}\n\nvar expandPairTrait = {\n  name: \"ExpandPairTrait\",\n  optionsTransformer: function optionsTransformer(options, docxtemplater) {\n    this.expandTags = docxtemplater.fileTypeConfig.expandTags.concat(docxtemplater.options.paragraphLoop ? docxtemplater.fileTypeConfig.onParagraphLoop : []);\n    return options;\n  },\n  postparse: function postparse(postparsed, _ref2) {\n    var _this = this;\n\n    var getTraits = _ref2.getTraits,\n        postparse = _ref2.postparse;\n    var traits = getTraits(traitName, postparsed);\n    traits = traits.map(function (trait) {\n      return trait || [];\n    });\n    traits = mergeSort(traits);\n\n    var _getPairs = getPairs(traits),\n        pairs = _getPairs.pairs,\n        errors = _getPairs.errors;\n\n    var lastRight = 0;\n    var lastPair = null;\n    var expandedPairs = pairs.map(function (pair) {\n      var expandTo = pair[0].part.expandTo;\n\n      if (expandTo === \"auto\") {\n        var result = getExpandToDefault(postparsed, pair, _this.expandTags);\n\n        if (result.error) {\n          errors.push(result.error);\n        }\n\n        expandTo = result.value;\n      }\n\n      if (!expandTo) {\n        var _left = pair[0].offset;\n        var _right = pair[1].offset;\n\n        if (_left < lastRight) {\n          errors.push(getUnbalancedLoopException(pair, lastPair));\n        }\n\n        lastPair = pair;\n        lastRight = _right;\n        return [_left, _right];\n      }\n\n      var left, right;\n\n      try {\n        left = getLeft(postparsed, expandTo, pair[0].offset);\n      } catch (e) {\n        errors.push(e);\n      }\n\n      try {\n        right = getRight(postparsed, expandTo, pair[1].offset);\n      } catch (e) {\n        errors.push(e);\n      }\n\n      if (left < lastRight) {\n        errors.push(getUnbalancedLoopException(pair, lastPair));\n      }\n\n      lastRight = right;\n      lastPair = pair;\n      return [left, right];\n    });\n\n    if (errors.length > 0) {\n      return {\n        postparsed: postparsed,\n        errors: errors\n      };\n    }\n\n    var currentPairIndex = 0;\n    var innerParts;\n    var newParsed = postparsed.reduce(function (newParsed, part, i) {\n      var inPair = currentPairIndex < pairs.length && expandedPairs[currentPairIndex][0] <= i && i <= expandedPairs[currentPairIndex][1];\n      var pair = pairs[currentPairIndex];\n      var expandedPair = expandedPairs[currentPairIndex];\n\n      if (!inPair) {\n        newParsed.push(part);\n        return newParsed;\n      }\n\n      if (expandedPair[0] === i) {\n        innerParts = [];\n      }\n\n      if (pair[0].offset !== i && pair[1].offset !== i) {\n        innerParts.push(part);\n      }\n\n      if (expandedPair[1] === i) {\n        var basePart = postparsed[pair[0].offset];\n        basePart.subparsed = postparse(innerParts, {\n          basePart: basePart\n        });\n        delete basePart.location;\n        delete basePart.expandTo;\n        newParsed.push(basePart);\n        currentPairIndex++;\n      }\n\n      return newParsed;\n    }, []);\n    return {\n      postparsed: newParsed,\n      errors: errors\n    };\n  }\n};\n\nmodule.exports = function () {\n  return wrapper(expandPairTrait);\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/modules/expand-pair-trait.js?");

/***/ }),

/***/ "./es6/modules/loop.js":
/*!*****************************!*\
  !*** ./es6/modules/loop.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar _require = __webpack_require__(/*! ../doc-utils */ \"./es6/doc-utils.js\"),\n    mergeObjects = _require.mergeObjects,\n    chunkBy = _require.chunkBy,\n    last = _require.last,\n    isParagraphStart = _require.isParagraphStart,\n    isParagraphEnd = _require.isParagraphEnd,\n    isContent = _require.isContent,\n    startsWith = _require.startsWith;\n\nvar wrapper = __webpack_require__(/*! ../module-wrapper */ \"./es6/module-wrapper.js\");\n\nvar moduleName = \"loop\";\n\nfunction hasContent(parts) {\n  return parts.some(function (part) {\n    return isContent(part);\n  });\n}\n\nfunction getFirstMeaningFulPart(parsed) {\n  for (var i = 0, len = parsed.length; i < len; i++) {\n    if (parsed[i].type !== \"content\") {\n      return parsed[i];\n    }\n  }\n\n  return null;\n}\n\nfunction isInsideParagraphLoop(part) {\n  var firstMeaningfulPart = getFirstMeaningFulPart(part.subparsed);\n  return firstMeaningfulPart != null && firstMeaningfulPart.tag !== \"w:t\";\n}\n\nfunction getPageBreakIfApplies(part) {\n  if (part.hasPageBreak) {\n    if (isInsideParagraphLoop(part)) {\n      return '<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>';\n    }\n  }\n\n  return \"\";\n}\n\nfunction isEnclosedByParagraphs(parsed) {\n  if (parsed.length === 0) {\n    return false;\n  }\n\n  return isParagraphStart(parsed[0]) && isParagraphEnd(last(parsed));\n}\n\nfunction getOffset(chunk) {\n  return hasContent(chunk) ? 0 : chunk.length;\n}\n\nfunction addPageBreakAtEnd(subRendered) {\n  var found = false;\n  var i = subRendered.parts.length - 1;\n\n  for (var j = subRendered.parts.length - 1; i >= 0; i--) {\n    var p = subRendered.parts[j];\n\n    if (p === \"</w:p>\" && !found) {\n      found = true;\n      subRendered.parts.splice(j, 0, '<w:r><w:br w:type=\"page\"/></w:r>');\n      break;\n    }\n  }\n\n  if (!found) {\n    subRendered.parts.push('<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>');\n  }\n}\n\nfunction addPageBreakAtBeginning(subRendered) {\n  subRendered.parts.unshift('<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>');\n}\n\nfunction addContinuousType(parts) {\n  var stop = false;\n  var inSectPr = false;\n  return parts.reduce(function (result, part) {\n    if (stop === false && startsWith(part, \"<w:sectPr\")) {\n      inSectPr = true;\n    }\n\n    if (inSectPr) {\n      if (startsWith(part, \"<w:type\")) {\n        stop = true;\n      }\n\n      if (stop === false && startsWith(part, \"</w:sectPr\")) {\n        result.push('<w:type w:val=\"continuous\"/>');\n      }\n    }\n\n    result.push(part);\n    return result;\n  }, []);\n}\n\nfunction dropHeaderFooterRefs(parts) {\n  return parts.filter(function (text) {\n    if (startsWith(text, \"<w:headerReference\") || startsWith(text, \"<w:footerReference\")) {\n      return false;\n    }\n\n    return true;\n  });\n}\n\nfunction hasPageBreak(chunk) {\n  return chunk.some(function (part) {\n    if (part.tag === \"w:br\" && part.value.indexOf('w:type=\"page\"') !== -1) {\n      return true;\n    }\n  });\n}\n\nfunction getSectPrHeaderFooterChangeCount(chunks) {\n  var collectSectPr = false;\n  var sectPrCount = 0;\n  chunks.forEach(function (part) {\n    if (part.tag === \"w:sectPr\" && part.position === \"start\") {\n      collectSectPr = true;\n    }\n\n    if (collectSectPr) {\n      if (part.tag === \"w:headerReference\" || part.tag === \"w:footerReference\") {\n        sectPrCount++;\n        collectSectPr = false;\n      }\n    }\n\n    if (part.tag === \"w:sectPr\" && part.position === \"end\") {\n      collectSectPr = false;\n    }\n  });\n  return sectPrCount;\n}\n\nvar LoopModule = /*#__PURE__*/function () {\n  function LoopModule() {\n    _classCallCheck(this, LoopModule);\n\n    this.name = \"LoopModule\";\n    this.totalSectPr = 0;\n    this.prefix = {\n      start: \"#\",\n      end: \"/\",\n      dash: /^-([^\\s]+)\\s(.+)$/,\n      inverted: \"^\"\n    };\n  }\n\n  _createClass(LoopModule, [{\n    key: \"parse\",\n    value: function parse(placeHolderContent, _ref) {\n      var match = _ref.match,\n          getValue = _ref.getValue,\n          getValues = _ref.getValues;\n      var module = moduleName;\n      var type = \"placeholder\";\n      var _this$prefix = this.prefix,\n          start = _this$prefix.start,\n          inverted = _this$prefix.inverted,\n          dash = _this$prefix.dash,\n          end = _this$prefix.end;\n\n      if (match(start, placeHolderContent)) {\n        return {\n          type: type,\n          value: getValue(start, placeHolderContent),\n          expandTo: \"auto\",\n          module: module,\n          location: \"start\",\n          inverted: false\n        };\n      }\n\n      if (match(inverted, placeHolderContent)) {\n        return {\n          type: type,\n          value: getValue(inverted, placeHolderContent),\n          expandTo: \"auto\",\n          module: module,\n          location: \"start\",\n          inverted: true\n        };\n      }\n\n      if (match(end, placeHolderContent)) {\n        return {\n          type: type,\n          value: getValue(end, placeHolderContent),\n          module: module,\n          location: \"end\"\n        };\n      }\n\n      if (match(dash, placeHolderContent)) {\n        var _getValues = getValues(dash, placeHolderContent),\n            _getValues2 = _slicedToArray(_getValues, 3),\n            expandTo = _getValues2[1],\n            value = _getValues2[2];\n\n        return {\n          type: type,\n          value: value,\n          expandTo: expandTo,\n          module: module,\n          location: \"start\",\n          inverted: false\n        };\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getTraits\",\n    value: function getTraits(traitName, parsed) {\n      if (traitName !== \"expandPair\") {\n        return;\n      }\n\n      return parsed.reduce(function (tags, part, offset) {\n        if (part.type === \"placeholder\" && part.module === moduleName && part.subparsed == null) {\n          tags.push({\n            part: part,\n            offset: offset\n          });\n        }\n\n        return tags;\n      }, []);\n    }\n  }, {\n    key: \"postparse\",\n    value: function postparse(parsed, _ref2) {\n      var basePart = _ref2.basePart;\n\n      if (basePart) {\n        basePart.sectPrCount = getSectPrHeaderFooterChangeCount(parsed);\n        basePart.sectPrIndex = this.totalSectPr;\n        this.totalSectPr += basePart.sectPrCount;\n      }\n\n      if (!basePart || basePart.expandTo !== \"auto\" || basePart.module !== moduleName || !isEnclosedByParagraphs(parsed)) {\n        return parsed;\n      }\n\n      var level = 0;\n      var chunks = chunkBy(parsed, function (p) {\n        if (isParagraphStart(p)) {\n          level++;\n\n          if (level === 1) {\n            return \"start\";\n          }\n        }\n\n        if (isParagraphEnd(p)) {\n          level--;\n\n          if (level === 0) {\n            return \"end\";\n          }\n        }\n\n        return null;\n      });\n\n      if (chunks.length <= 2) {\n        return parsed;\n      }\n\n      var firstChunk = chunks[0];\n      var lastChunk = last(chunks);\n      var firstOffset = getOffset(firstChunk);\n      var lastOffset = getOffset(lastChunk);\n      basePart.hasPageBreak = hasPageBreak(lastChunk);\n      basePart.hasPageBreakBeginning = hasPageBreak(firstChunk);\n\n      if (firstOffset === 0 || lastOffset === 0) {\n        return parsed;\n      }\n\n      return parsed.slice(firstOffset, parsed.length - lastOffset);\n    }\n  }, {\n    key: \"render\",\n    value: function render(part, options) {\n      if (part.type !== \"placeholder\" || part.module !== moduleName) {\n        return null;\n      }\n\n      var totalValue = [];\n      var errors = [];\n\n      function loopOver(scope, i, length) {\n        var scopeManager = options.scopeManager.createSubScopeManager(scope, part.value, i, part, length);\n        var subRendered = options.render(mergeObjects({}, options, {\n          compiled: part.subparsed,\n          tags: {},\n          scopeManager: scopeManager\n        }));\n\n        if (part.hasPageBreak && i === length - 1 && isInsideParagraphLoop(part)) {\n          addPageBreakAtEnd(subRendered);\n        }\n\n        var isNotFirst = scopeManager.scopePathItem.some(function (i) {\n          return i !== 0;\n        });\n\n        if (isNotFirst) {\n          if (part.sectPrCount === 1) {\n            subRendered.parts = dropHeaderFooterRefs(subRendered.parts);\n          }\n\n          if (part.sectPrIndex === 0) {\n            // For the first sectPr in the document, add the continuous attribute (except for the first iteration)\n            subRendered.parts = addContinuousType(subRendered.parts);\n          }\n        }\n\n        if (part.hasPageBreakBeginning && isInsideParagraphLoop(part)) {\n          addPageBreakAtBeginning(subRendered);\n        }\n\n        totalValue = totalValue.concat(subRendered.parts);\n        errors = errors.concat(subRendered.errors || []);\n      }\n\n      var result;\n\n      try {\n        result = options.scopeManager.loopOver(part.value, loopOver, part.inverted, {\n          part: part\n        });\n      } catch (e) {\n        errors.push(e);\n        return {\n          errors: errors\n        };\n      } // if the loop is showing empty content\n\n\n      if (result === false) {\n        return {\n          value: getPageBreakIfApplies(part) || \"\",\n          errors: errors\n        };\n      }\n\n      return {\n        value: options.joinUncorrupt(totalValue, _objectSpread(_objectSpread({}, options), {}, {\n          basePart: part\n        })),\n        errors: errors\n      };\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(part, options) {\n      if (part.type !== \"placeholder\" || part.module !== moduleName) {\n        return null;\n      }\n\n      var sm = options.scopeManager;\n      var promisedValue = sm.getValueAsync(part.value, {\n        part: part\n      });\n      var promises = [];\n\n      function loopOver(scope, i, length) {\n        var scopeManager = sm.createSubScopeManager(scope, part.value, i, part, length);\n        promises.push(options.resolve({\n          filePath: options.filePath,\n          modules: options.modules,\n          baseNullGetter: options.baseNullGetter,\n          resolve: options.resolve,\n          compiled: part.subparsed,\n          tags: {},\n          scopeManager: scopeManager\n        }));\n      }\n\n      var errorList = [];\n      return promisedValue.then(function (value) {\n        sm.loopOverValue(value, loopOver, part.inverted);\n        return Promise.all(promises).then(function (r) {\n          return r.map(function (_ref3) {\n            var resolved = _ref3.resolved,\n                errors = _ref3.errors;\n\n            if (errors.length > 0) {\n              errorList.push.apply(errorList, _toConsumableArray(errors));\n            }\n\n            return resolved;\n          });\n        }).then(function (value) {\n          if (errorList.length > 0) {\n            throw errorList;\n          }\n\n          return value;\n        });\n      });\n    }\n  }]);\n\n  return LoopModule;\n}();\n\nmodule.exports = function () {\n  return wrapper(new LoopModule());\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/modules/loop.js?");

/***/ }),

/***/ "./es6/modules/rawxml.js":
/*!*******************************!*\
  !*** ./es6/modules/rawxml.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar traits = __webpack_require__(/*! ../traits */ \"./es6/traits.js\");\n\nvar _require = __webpack_require__(/*! ../doc-utils */ \"./es6/doc-utils.js\"),\n    isContent = _require.isContent;\n\nvar _require2 = __webpack_require__(/*! ../errors */ \"./es6/errors.js\"),\n    throwRawTagShouldBeOnlyTextInParagraph = _require2.throwRawTagShouldBeOnlyTextInParagraph;\n\nvar moduleName = \"rawxml\";\n\nvar wrapper = __webpack_require__(/*! ../module-wrapper */ \"./es6/module-wrapper.js\");\n\nfunction getInner(_ref) {\n  var part = _ref.part,\n      left = _ref.left,\n      right = _ref.right,\n      postparsed = _ref.postparsed,\n      index = _ref.index;\n  var paragraphParts = postparsed.slice(left + 1, right);\n  paragraphParts.forEach(function (p, i) {\n    if (i === index - left - 1) {\n      return;\n    }\n\n    if (isContent(p)) {\n      throwRawTagShouldBeOnlyTextInParagraph({\n        paragraphParts: paragraphParts,\n        part: part\n      });\n    }\n  });\n  return part;\n}\n\nvar RawXmlModule = /*#__PURE__*/function () {\n  function RawXmlModule() {\n    _classCallCheck(this, RawXmlModule);\n\n    this.name = \"RawXmlModule\";\n    this.prefix = \"@\";\n  }\n\n  _createClass(RawXmlModule, [{\n    key: \"optionsTransformer\",\n    value: function optionsTransformer(options, docxtemplater) {\n      this.fileTypeConfig = docxtemplater.fileTypeConfig;\n      return options;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(placeHolderContent, _ref2) {\n      var match = _ref2.match,\n          getValue = _ref2.getValue;\n      var type = \"placeholder\";\n\n      if (match(this.prefix, placeHolderContent)) {\n        return {\n          type: type,\n          value: getValue(this.prefix, placeHolderContent),\n          module: moduleName\n        };\n      }\n\n      return null;\n    }\n  }, {\n    key: \"postparse\",\n    value: function postparse(postparsed) {\n      return traits.expandToOne(postparsed, {\n        moduleName: moduleName,\n        getInner: getInner,\n        expandTo: this.fileTypeConfig.tagRawXml,\n        error: {\n          message: \"Raw tag not in paragraph\",\n          id: \"raw_tag_outerxml_invalid\",\n          explanation: function explanation(part) {\n            return \"The tag \\\"\".concat(part.value, \"\\\" is not inside a paragraph, putting raw tags inside an inline loop is disallowed.\");\n          }\n        }\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render(part, options) {\n      if (part.module !== moduleName) {\n        return null;\n      }\n\n      var value;\n      var errors = [];\n\n      try {\n        value = options.scopeManager.getValue(part.value, {\n          part: part\n        });\n\n        if (value == null) {\n          value = options.nullGetter(part);\n        }\n      } catch (e) {\n        errors.push(e);\n        return {\n          errors: errors\n        };\n      }\n\n      if (!value) {\n        return {\n          value: \"\"\n        };\n      }\n\n      return {\n        value: value\n      };\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(part, options) {\n      if (part.type !== \"placeholder\" || part.module !== moduleName) {\n        return null;\n      }\n\n      return options.scopeManager.getValueAsync(part.value, {\n        part: part\n      }).then(function (value) {\n        if (value == null) {\n          return options.nullGetter(part);\n        }\n\n        return value;\n      });\n    }\n  }]);\n\n  return RawXmlModule;\n}();\n\nmodule.exports = function () {\n  return wrapper(new RawXmlModule());\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/modules/rawxml.js?");

/***/ }),

/***/ "./es6/modules/render.js":
/*!*******************************!*\
  !*** ./es6/modules/render.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar wrapper = __webpack_require__(/*! ../module-wrapper */ \"./es6/module-wrapper.js\");\n\nvar _require = __webpack_require__(/*! ../errors */ \"./es6/errors.js\"),\n    getScopeCompilationError = _require.getScopeCompilationError;\n\nvar _require2 = __webpack_require__(/*! ../doc-utils */ \"./es6/doc-utils.js\"),\n    utf8ToWord = _require2.utf8ToWord,\n    hasCorruptCharacters = _require2.hasCorruptCharacters;\n\nvar _require3 = __webpack_require__(/*! ../errors */ \"./es6/errors.js\"),\n    getCorruptCharactersException = _require3.getCorruptCharactersException;\n\nvar ftprefix = {\n  docx: \"w\",\n  pptx: \"a\"\n};\n\nvar Render = /*#__PURE__*/function () {\n  function Render() {\n    _classCallCheck(this, Render);\n\n    this.name = \"Render\";\n    this.recordRun = false;\n    this.recordedRun = [];\n  }\n\n  _createClass(Render, [{\n    key: \"set\",\n    value: function set(obj) {\n      if (obj.compiled) {\n        this.compiled = obj.compiled;\n      }\n\n      if (obj.data != null) {\n        this.data = obj.data;\n      }\n    }\n  }, {\n    key: \"getRenderedMap\",\n    value: function getRenderedMap(mapper) {\n      var _this = this;\n\n      return Object.keys(this.compiled).reduce(function (mapper, from) {\n        mapper[from] = {\n          from: from,\n          data: _this.data\n        };\n        return mapper;\n      }, mapper);\n    }\n  }, {\n    key: \"optionsTransformer\",\n    value: function optionsTransformer(options, docxtemplater) {\n      this.parser = docxtemplater.parser;\n      this.fileType = docxtemplater.fileType;\n      return options;\n    }\n  }, {\n    key: \"postparse\",\n    value: function postparse(postparsed, options) {\n      var _this2 = this;\n\n      var errors = [];\n      postparsed.forEach(function (p) {\n        if (p.type === \"placeholder\") {\n          var tag = p.value;\n\n          try {\n            options.cachedParsers[p.lIndex] = _this2.parser(tag, {\n              tag: p\n            });\n          } catch (rootError) {\n            errors.push(getScopeCompilationError({\n              tag: tag,\n              rootError: rootError,\n              offset: p.offset\n            }));\n          }\n        }\n      });\n      return {\n        postparsed: postparsed,\n        errors: errors\n      };\n    }\n  }, {\n    key: \"recordRuns\",\n    value: function recordRuns(part) {\n      if (part.tag === \"\".concat(ftprefix[this.fileType], \":r\")) {\n        this.recordRun = false;\n        this.recordedRun = [];\n      } else if (part.tag === \"\".concat(ftprefix[this.fileType], \":rPr\")) {\n        if (part.position === \"start\") {\n          this.recordRun = true;\n          this.recordedRun = [part.value];\n        }\n\n        if (part.position === \"end\") {\n          this.recordedRun.push(part.value);\n          this.recordRun = false;\n        }\n      } else if (this.recordRun) {\n        this.recordedRun.push(part.value);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render(part, _ref) {\n      var scopeManager = _ref.scopeManager,\n          linebreaks = _ref.linebreaks,\n          nullGetter = _ref.nullGetter;\n\n      if (linebreaks) {\n        this.recordRuns(part);\n      }\n\n      if (part.type !== \"placeholder\" || part.module) {\n        return;\n      }\n\n      var value;\n\n      try {\n        value = scopeManager.getValue(part.value, {\n          part: part\n        });\n      } catch (e) {\n        return {\n          errors: [e]\n        };\n      }\n\n      if (value == null) {\n        value = nullGetter(part);\n      }\n\n      if (hasCorruptCharacters(value)) {\n        return {\n          errors: [getCorruptCharactersException({\n            tag: part.value,\n            value: value,\n            offset: part.offset\n          })]\n        };\n      }\n\n      if (typeof value !== \"string\") {\n        value = value.toString();\n      }\n\n      if (linebreaks) {\n        return this.renderLineBreaks(value);\n      }\n\n      return {\n        value: utf8ToWord(value)\n      };\n    }\n  }, {\n    key: \"renderLineBreaks\",\n    value: function renderLineBreaks(value) {\n      var p = ftprefix[this.fileType];\n      var br = this.fileType === \"docx\" ? \"<w:r><w:br/></w:r>\" : \"<a:br/>\";\n      var lines = value.split(\"\\n\");\n      var runprops = this.recordedRun.join(\"\");\n      return {\n        value: lines.map(function (line) {\n          return utf8ToWord(line);\n        }).join(\"</\".concat(p, \":t></\").concat(p, \":r>\").concat(br, \"<\").concat(p, \":r>\").concat(runprops, \"<\").concat(p, \":t\").concat(this.fileType === \"docx\" ? ' xml:space=\"preserve\"' : \"\", \">\"))\n      };\n    }\n  }]);\n\n  return Render;\n}();\n\nmodule.exports = function () {\n  return wrapper(new Render());\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/modules/render.js?");

/***/ }),

/***/ "./es6/modules/space-preserve.js":
/*!***************************************!*\
  !*** ./es6/modules/space-preserve.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var wrapper = __webpack_require__(/*! ../module-wrapper */ \"./es6/module-wrapper.js\");\n\nvar _require = __webpack_require__(/*! ../doc-utils */ \"./es6/doc-utils.js\"),\n    isTextStart = _require.isTextStart,\n    isTextEnd = _require.isTextEnd,\n    endsWith = _require.endsWith,\n    startsWith = _require.startsWith;\n\nvar wTpreserve = '<w:t xml:space=\"preserve\">';\nvar wTpreservelen = wTpreserve.length;\nvar wtEnd = \"</w:t>\";\nvar wtEndlen = wtEnd.length;\n\nfunction isWtStart(part) {\n  return isTextStart(part) && part.tag === \"w:t\";\n}\n\nfunction addXMLPreserve(chunk, index) {\n  var tag = chunk[index].value;\n\n  if (chunk[index + 1].value === \"</w:t>\") {\n    return tag;\n  }\n\n  if (tag.indexOf('xml:space=\"preserve\"') !== -1) {\n    return tag;\n  }\n\n  return tag.substr(0, tag.length - 1) + ' xml:space=\"preserve\">';\n}\n\nfunction isInsideLoop(meta, chunk) {\n  return meta && meta.basePart && chunk.length > 1;\n}\n\nvar spacePreserve = {\n  name: \"SpacePreserveModule\",\n  postparse: function postparse(postparsed, meta) {\n    var chunk = [],\n        inTextTag = false,\n        endLindex = 0,\n        lastTextTag = 0;\n\n    function isStartingPlaceHolder(part, chunk) {\n      return part.type === \"placeholder\" && (!part.module || part.module === \"loop\") && chunk.length > 1;\n    }\n\n    var result = postparsed.reduce(function (postparsed, part) {\n      if (isWtStart(part)) {\n        inTextTag = true;\n        lastTextTag = chunk.length;\n      }\n\n      if (!inTextTag) {\n        postparsed.push(part);\n        return postparsed;\n      }\n\n      chunk.push(part);\n\n      if (isInsideLoop(meta, chunk)) {\n        endLindex = meta.basePart.endLindex;\n        chunk[0].value = addXMLPreserve(chunk, 0);\n      }\n\n      if (isStartingPlaceHolder(part, chunk)) {\n        chunk[lastTextTag].value = addXMLPreserve(chunk, lastTextTag);\n        endLindex = part.endLindex;\n      }\n\n      if (isTextEnd(part) && part.lIndex > endLindex) {\n        if (endLindex !== 0) {\n          chunk[lastTextTag].value = addXMLPreserve(chunk, lastTextTag);\n        }\n\n        Array.prototype.push.apply(postparsed, chunk);\n        chunk = [];\n        inTextTag = false;\n        endLindex = 0;\n        lastTextTag = 0;\n      }\n\n      return postparsed;\n    }, []);\n    Array.prototype.push.apply(result, chunk);\n    return result;\n  },\n  postrender: function postrender(parts) {\n    var lastNonEmpty = \"\";\n    var lastNonEmptyIndex = 0;\n    return parts.reduce(function (newParts, p, index) {\n      if (p === \"\") {\n        newParts.push(p);\n        return newParts;\n      }\n\n      if (p.indexOf('<w:t xml:space=\"preserve\"></w:t>') !== -1) {\n        p = p.replace(/<w:t xml:space=\"preserve\"><\\/w:t>/g, \"<w:t/>\");\n      }\n\n      if (endsWith(lastNonEmpty, wTpreserve) && startsWith(p, wtEnd)) {\n        newParts[lastNonEmptyIndex] = lastNonEmpty.substr(0, lastNonEmpty.length - wTpreservelen) + \"<w:t/>\";\n        p = p.substr(wtEndlen);\n      }\n\n      lastNonEmpty = p;\n      lastNonEmptyIndex = index;\n      newParts.push(p);\n      return newParts;\n    }, []);\n  }\n};\n\nmodule.exports = function () {\n  return wrapper(spacePreserve);\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/modules/space-preserve.js?");

/***/ }),

/***/ "./es6/parser.js":
/*!***********************!*\
  !*** ./es6/parser.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar _require = __webpack_require__(/*! ./doc-utils */ \"./es6/doc-utils.js\"),\n    wordToUtf8 = _require.wordToUtf8,\n    concatArrays = _require.concatArrays;\n\nvar _require2 = __webpack_require__(/*! ./prefix-matcher */ \"./es6/prefix-matcher.js\"),\n    match = _require2.match,\n    getValue = _require2.getValue,\n    getValues = _require2.getValues;\n\nfunction moduleParse(placeHolderContent, options) {\n  var modules = options.modules;\n  var startOffset = options.startOffset;\n  var endLindex = options.lIndex;\n  var moduleParsed;\n  options.offset = startOffset;\n  options.lIndex = endLindex;\n  options.match = match;\n  options.getValue = getValue;\n  options.getValues = getValues;\n\n  for (var i = 0, l = modules.length; i < l; i++) {\n    var _module = modules[i];\n    moduleParsed = _module.parse(placeHolderContent, options);\n\n    if (moduleParsed) {\n      moduleParsed.offset = startOffset;\n      moduleParsed.endLindex = endLindex;\n      moduleParsed.lIndex = endLindex;\n      moduleParsed.raw = placeHolderContent;\n      return moduleParsed;\n    }\n  }\n\n  return {\n    type: \"placeholder\",\n    value: placeHolderContent,\n    offset: startOffset,\n    endLindex: endLindex,\n    lIndex: endLindex\n  };\n}\n\nvar parser = {\n  preparse: function preparse(parsed, modules, options) {\n    function preparse(parsed, options) {\n      return modules.forEach(function (module) {\n        module.preparse(parsed, options);\n      });\n    }\n\n    return {\n      preparsed: preparse(parsed, options)\n    };\n  },\n  postparse: function postparse(postparsed, modules, options) {\n    function getTraits(traitName, postparsed) {\n      return modules.map(function (module) {\n        return module.getTraits(traitName, postparsed);\n      });\n    }\n\n    var errors = [];\n\n    function _postparse(postparsed, options) {\n      return modules.reduce(function (postparsed, module) {\n        var r = module.postparse(postparsed, _objectSpread(_objectSpread({}, options), {}, {\n          postparse: function postparse(parsed, opts) {\n            return _postparse(parsed, _objectSpread(_objectSpread({}, options), opts));\n          },\n          getTraits: getTraits\n        }));\n\n        if (r == null) {\n          return postparsed;\n        }\n\n        if (r.errors) {\n          errors = concatArrays([errors, r.errors]);\n          return r.postparsed;\n        }\n\n        return r;\n      }, postparsed);\n    }\n\n    return {\n      postparsed: _postparse(postparsed, options),\n      errors: errors\n    };\n  },\n  parse: function parse(lexed, modules, options) {\n    var inPlaceHolder = false;\n    var placeHolderContent = \"\";\n    var startOffset;\n    var tailParts = [];\n    return lexed.reduce(function lexedToParsed(parsed, token) {\n      if (token.type === \"delimiter\") {\n        inPlaceHolder = token.position === \"start\";\n\n        if (token.position === \"end\") {\n          placeHolderContent = wordToUtf8(placeHolderContent);\n\n          options.parse = function (placeHolderContent) {\n            return moduleParse(placeHolderContent, _objectSpread(_objectSpread(_objectSpread({}, options), token), {}, {\n              startOffset: startOffset,\n              modules: modules\n            }));\n          };\n\n          parsed.push(options.parse(placeHolderContent));\n          Array.prototype.push.apply(parsed, tailParts);\n          tailParts = [];\n        }\n\n        if (token.position === \"start\") {\n          tailParts = [];\n          startOffset = token.offset;\n        }\n\n        placeHolderContent = \"\";\n        return parsed;\n      }\n\n      if (!inPlaceHolder) {\n        parsed.push(token);\n        return parsed;\n      }\n\n      if (token.type !== \"content\" || token.position !== \"insidetag\") {\n        tailParts.push(token);\n        return parsed;\n      }\n\n      placeHolderContent += token.value;\n      return parsed;\n    }, []);\n  }\n};\nmodule.exports = parser;\n\n//# sourceURL=webpack://docxtemplater/./es6/parser.js?");

/***/ }),

/***/ "./es6/postrender.js":
/*!***************************!*\
  !*** ./es6/postrender.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction postrender(parts, options) {\n  for (var i = 0, l = options.modules.length; i < l; i++) {\n    var _module = options.modules[i];\n    parts = _module.postrender(parts, options);\n  }\n\n  return options.joinUncorrupt(parts, options);\n}\n\nmodule.exports = postrender;\n\n//# sourceURL=webpack://docxtemplater/./es6/postrender.js?");

/***/ }),

/***/ "./es6/prefix-matcher.js":
/*!*******************************!*\
  !*** ./es6/prefix-matcher.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function match(condition, placeHolderContent) {\n  if (typeof condition === \"string\") {\n    return placeHolderContent.substr(0, condition.length) === condition;\n  }\n\n  if (condition instanceof RegExp) {\n    return condition.test(placeHolderContent);\n  }\n}\n\nfunction getValue(condition, placeHolderContent) {\n  if (typeof condition === \"string\") {\n    return placeHolderContent.substr(condition.length);\n  }\n\n  if (condition instanceof RegExp) {\n    return placeHolderContent.match(condition)[1];\n  }\n}\n\nfunction getValues(condition, placeHolderContent) {\n  if (condition instanceof RegExp) {\n    return placeHolderContent.match(condition);\n  }\n}\n\nmodule.exports = {\n  match: match,\n  getValue: getValue,\n  getValues: getValues\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/prefix-matcher.js?");

/***/ }),

/***/ "./es6/render.js":
/*!***********************!*\
  !*** ./es6/render.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _require = __webpack_require__(/*! ./doc-utils */ \"./es6/doc-utils.js\"),\n    concatArrays = _require.concatArrays;\n\nvar _require2 = __webpack_require__(/*! ./errors */ \"./es6/errors.js\"),\n    throwUnimplementedTagType = _require2.throwUnimplementedTagType;\n\nfunction moduleRender(part, options) {\n  var moduleRendered;\n\n  for (var i = 0, l = options.modules.length; i < l; i++) {\n    var _module = options.modules[i];\n    moduleRendered = _module.render(part, options);\n\n    if (moduleRendered) {\n      return moduleRendered;\n    }\n  }\n\n  return false;\n}\n\nfunction render(options) {\n  var baseNullGetter = options.baseNullGetter;\n  var compiled = options.compiled,\n      scopeManager = options.scopeManager;\n\n  options.nullGetter = function (part, sm) {\n    return baseNullGetter(part, sm || scopeManager);\n  };\n\n  if (!options.prefix) {\n    options.prefix = \"\";\n  }\n\n  if (options.index) {\n    options.prefix = options.prefix + options.index + \"-\";\n  }\n\n  var errors = [];\n  var parts = compiled.map(function (part, i) {\n    options.index = i;\n    var moduleRendered = moduleRender(part, options);\n\n    if (moduleRendered) {\n      if (moduleRendered.errors) {\n        errors = concatArrays([errors, moduleRendered.errors]);\n      }\n\n      return moduleRendered.value;\n    }\n\n    if (part.type === \"content\" || part.type === \"tag\") {\n      return part.value;\n    }\n\n    throwUnimplementedTagType(part, i);\n  });\n  return {\n    errors: errors,\n    parts: parts\n  };\n}\n\nmodule.exports = render;\n\n//# sourceURL=webpack://docxtemplater/./es6/render.js?");

/***/ }),

/***/ "./es6/resolve.js":
/*!************************!*\
  !*** ./es6/resolve.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction moduleResolve(part, options) {\n  var moduleResolved;\n\n  for (var i = 0, l = options.modules.length; i < l; i++) {\n    var _module = options.modules[i];\n    moduleResolved = _module.resolve(part, options);\n\n    if (moduleResolved) {\n      return moduleResolved;\n    }\n  }\n\n  return false;\n}\n\nfunction resolve(options) {\n  var resolved = [];\n  var baseNullGetter = options.baseNullGetter;\n  var compiled = options.compiled,\n      scopeManager = options.scopeManager;\n\n  options.nullGetter = function (part, sm) {\n    return baseNullGetter(part, sm || scopeManager);\n  };\n\n  options.resolved = resolved;\n  var errors = [];\n  return Promise.all(compiled.filter(function (part) {\n    return [\"content\", \"tag\"].indexOf(part.type) === -1;\n  }).reduce(function (promises, part) {\n    var moduleResolved = moduleResolve(part, options);\n    var result;\n\n    if (moduleResolved) {\n      result = moduleResolved.then(function (value) {\n        resolved.push({\n          tag: part.value,\n          value: value,\n          lIndex: part.lIndex\n        });\n      });\n    } else if (part.type === \"placeholder\") {\n      result = scopeManager.getValueAsync(part.value, {\n        part: part\n      }).then(function (value) {\n        if (value == null) {\n          value = options.nullGetter(part);\n        }\n\n        resolved.push({\n          tag: part.value,\n          value: value,\n          lIndex: part.lIndex\n        });\n        return value;\n      });\n    } else {\n      return;\n    }\n\n    promises.push(result[\"catch\"](function (e) {\n      if (e.length > 1) {\n        errors.push.apply(errors, _toConsumableArray(e));\n      } else {\n        errors.push(e);\n      }\n    }));\n    return promises;\n  }, [])).then(function () {\n    return {\n      errors: errors,\n      resolved: resolved\n    };\n  });\n}\n\nmodule.exports = resolve;\n\n//# sourceURL=webpack://docxtemplater/./es6/resolve.js?");

/***/ }),

/***/ "./es6/scope-manager.js":
/*!******************************!*\
  !*** ./es6/scope-manager.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar _require = __webpack_require__(/*! ./errors */ \"./es6/errors.js\"),\n    getScopeParserExecutionError = _require.getScopeParserExecutionError;\n\nvar _require2 = __webpack_require__(/*! ./utils */ \"./es6/utils.js\"),\n    last = _require2.last;\n\nvar _require3 = __webpack_require__(/*! ./doc-utils */ \"./es6/doc-utils.js\"),\n    concatArrays = _require3.concatArrays;\n\nfunction find(list, fn) {\n  var length = list.length >>> 0;\n  var value;\n\n  for (var i = 0; i < length; i++) {\n    value = list[i];\n\n    if (fn.call(this, value, i, list)) {\n      return value;\n    }\n  }\n\n  return undefined;\n}\n\nfunction _getValue(tag, meta, num) {\n  var _this = this;\n\n  var scope = this.scopeList[num];\n\n  if (this.root.finishedResolving) {\n    var w = this.resolved;\n    this.scopePath.forEach(function (p, index) {\n      var lIndex = _this.scopeLindex[index];\n      w = find(w, function (r) {\n        return r.lIndex === lIndex;\n      });\n      w = w.value[_this.scopePathItem[index]];\n    });\n    return [this.scopePath.length - 1, find(w, function (r) {\n      return meta.part.lIndex === r.lIndex;\n    }).value];\n  } // search in the scopes (in reverse order) and keep the first defined value\n\n\n  var result;\n  var parser;\n\n  if (!this.cachedParsers || !meta.part) {\n    parser = this.parser(tag, {\n      scopePath: this.scopePath\n    });\n  } else if (this.cachedParsers[meta.part.lIndex]) {\n    parser = this.cachedParsers[meta.part.lIndex];\n  } else {\n    parser = this.cachedParsers[meta.part.lIndex] = this.parser(tag, {\n      scopePath: this.scopePath\n    });\n  }\n\n  try {\n    result = parser.get(scope, this.getContext(meta, num));\n  } catch (error) {\n    throw getScopeParserExecutionError({\n      tag: tag,\n      scope: scope,\n      error: error,\n      offset: meta.part.offset\n    });\n  }\n\n  if (result == null && num > 0) {\n    return _getValue.call(this, tag, meta, num - 1);\n  }\n\n  return [num, result];\n}\n\nfunction _getValueAsync(tag, meta, num) {\n  var _this2 = this;\n\n  var scope = this.scopeList[num]; // search in the scopes (in reverse order) and keep the first defined value\n\n  var parser;\n\n  if (!this.cachedParsers || !meta.part) {\n    parser = this.parser(tag, {\n      scopePath: this.scopePath\n    });\n  } else if (this.cachedParsers[meta.part.lIndex]) {\n    parser = this.cachedParsers[meta.part.lIndex];\n  } else {\n    parser = this.cachedParsers[meta.part.lIndex] = this.parser(tag, {\n      scopePath: this.scopePath\n    });\n  }\n\n  return Promise.resolve().then(function () {\n    return parser.get(scope, _this2.getContext(meta, num));\n  })[\"catch\"](function (error) {\n    throw getScopeParserExecutionError({\n      tag: tag,\n      scope: scope,\n      error: error,\n      offset: meta.part.offset\n    });\n  }).then(function (result) {\n    if (result == null && num > 0) {\n      return _getValueAsync.call(_this2, tag, meta, num - 1);\n    }\n\n    return result;\n  });\n} // This class responsibility is to manage the scope\n\n\nvar ScopeManager = /*#__PURE__*/function () {\n  function ScopeManager(options) {\n    _classCallCheck(this, ScopeManager);\n\n    this.root = options.root || this;\n    this.scopePath = options.scopePath;\n    this.scopePathItem = options.scopePathItem;\n    this.scopePathLength = options.scopePathLength;\n    this.scopeList = options.scopeList;\n    this.scopeLindex = options.scopeLindex;\n    this.parser = options.parser;\n    this.resolved = options.resolved;\n    this.cachedParsers = options.cachedParsers;\n  }\n\n  _createClass(ScopeManager, [{\n    key: \"loopOver\",\n    value: function loopOver(tag, functor, inverted, meta) {\n      return this.loopOverValue(this.getValue(tag, meta), functor, inverted);\n    }\n  }, {\n    key: \"functorIfInverted\",\n    value: function functorIfInverted(inverted, functor, value, i, length) {\n      if (inverted) {\n        functor(value, i, length);\n      }\n\n      return inverted;\n    }\n  }, {\n    key: \"isValueFalsy\",\n    value: function isValueFalsy(value, type) {\n      return value == null || !value || type === \"[object Array]\" && value.length === 0;\n    }\n  }, {\n    key: \"loopOverValue\",\n    value: function loopOverValue(value, functor, inverted) {\n      if (this.root.finishedResolving) {\n        inverted = false;\n      }\n\n      var type = Object.prototype.toString.call(value);\n\n      if (this.isValueFalsy(value, type)) {\n        return this.functorIfInverted(inverted, functor, last(this.scopeList), 0, 1);\n      }\n\n      if (type === \"[object Array]\") {\n        for (var i = 0; i < value.length; i++) {\n          this.functorIfInverted(!inverted, functor, value[i], i, value.length);\n        }\n\n        return true;\n      }\n\n      if (type === \"[object Object]\") {\n        return this.functorIfInverted(!inverted, functor, value, 0, 1);\n      }\n\n      return this.functorIfInverted(!inverted, functor, last(this.scopeList), 0, 1);\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue(tag, meta) {\n      var _getValue$call = _getValue.call(this, tag, meta, this.scopeList.length - 1),\n          _getValue$call2 = _slicedToArray(_getValue$call, 2),\n          num = _getValue$call2[0],\n          result = _getValue$call2[1];\n\n      this.num = num;\n      return result;\n    }\n  }, {\n    key: \"getValueAsync\",\n    value: function getValueAsync(tag, meta) {\n      return _getValueAsync.call(this, tag, meta, this.scopeList.length - 1);\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext(meta, num) {\n      return {\n        num: num,\n        meta: meta,\n        scopeList: this.scopeList,\n        resolved: this.resolved,\n        scopePath: this.scopePath,\n        scopePathItem: this.scopePathItem,\n        scopePathLength: this.scopePathLength\n      };\n    }\n  }, {\n    key: \"createSubScopeManager\",\n    value: function createSubScopeManager(scope, tag, i, part, length) {\n      return new ScopeManager({\n        root: this.root,\n        resolved: this.resolved,\n        parser: this.parser,\n        cachedParsers: this.cachedParsers,\n        scopeList: concatArrays([this.scopeList, [scope]]),\n        scopePath: concatArrays([this.scopePath, [tag]]),\n        scopePathItem: concatArrays([this.scopePathItem, [i]]),\n        scopePathLength: concatArrays([this.scopePathLength, [length]]),\n        scopeLindex: concatArrays([this.scopeLindex, [part.lIndex]])\n      });\n    }\n  }]);\n\n  return ScopeManager;\n}();\n\nmodule.exports = function (options) {\n  options.scopePath = [];\n  options.scopePathItem = [];\n  options.scopePathLength = [];\n  options.scopeLindex = [];\n  options.scopeList = [options.tags];\n  return new ScopeManager(options);\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/scope-manager.js?");

/***/ }),

/***/ "./es6/traits.js":
/*!***********************!*\
  !*** ./es6/traits.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar _require = __webpack_require__(/*! ./doc-utils */ \"./es6/doc-utils.js\"),\n    getRightOrNull = _require.getRightOrNull,\n    getRight = _require.getRight,\n    getLeft = _require.getLeft,\n    getLeftOrNull = _require.getLeftOrNull,\n    chunkBy = _require.chunkBy,\n    isTagStart = _require.isTagStart,\n    isTagEnd = _require.isTagEnd,\n    isContent = _require.isContent,\n    last = _require.last,\n    first = _require.first;\n\nvar _require2 = __webpack_require__(/*! ./errors */ \"./es6/errors.js\"),\n    XTTemplateError = _require2.XTTemplateError,\n    throwExpandNotFound = _require2.throwExpandNotFound,\n    getLoopPositionProducesInvalidXMLError = _require2.getLoopPositionProducesInvalidXMLError;\n\nfunction lastTagIsOpenTag(tags, tag) {\n  if (tags.length === 0) {\n    return false;\n  }\n\n  var innerLastTag = last(tags).tag.substr(1);\n  var innerCurrentTag = tag.substr(2, tag.length - 3);\n  return innerLastTag.indexOf(innerCurrentTag) === 0;\n}\n\nfunction addTag(tags, tag) {\n  tags.push({\n    tag: tag\n  });\n  return tags;\n}\n\nfunction getListXmlElements(parts) {\n  /*\n  get the different closing and opening tags between two texts (doesn't take into account tags that are opened then closed (those that are closed then opened are returned)):\n  returns:[{\"tag\":\"</w:r>\",\"offset\":13},{\"tag\":\"</w:p>\",\"offset\":265},{\"tag\":\"</w:tc>\",\"offset\":271},{\"tag\":\"<w:tc>\",\"offset\":828},{\"tag\":\"<w:p>\",\"offset\":883},{\"tag\":\"<w:r>\",\"offset\":1483}]\n  */\n  var tags = parts.filter(function (part) {\n    return part.type === \"tag\";\n  });\n  var result = [];\n\n  for (var i = 0, tag; i < tags.length; i++) {\n    tag = tags[i].value; // closing tag\n\n    if (tag[1] === \"/\") {\n      if (lastTagIsOpenTag(result, tag)) {\n        result.pop();\n      } else {\n        result = addTag(result, tag);\n      }\n    } else if (tag[tag.length - 2] !== \"/\") {\n      result = addTag(result, tag);\n    }\n  }\n\n  return result;\n}\n\nfunction has(name, xmlElements) {\n  for (var i = 0; i < xmlElements.length; i++) {\n    var xmlElement = xmlElements[i];\n\n    if (xmlElement.tag.indexOf(\"<\".concat(name)) === 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getExpandToDefault(postparsed, pair, expandTags) {\n  var parts = postparsed.slice(pair[0].offset, pair[1].offset);\n  var xmlElements = getListXmlElements(parts);\n  var closingTagCount = xmlElements.filter(function (xmlElement) {\n    return xmlElement.tag[1] === \"/\";\n  }).length;\n  var startingTagCount = xmlElements.filter(function (xmlElement) {\n    var tag = xmlElement.tag;\n    return tag[1] !== \"/\" && tag[tag.length - 2] !== \"/\";\n  }).length;\n\n  if (closingTagCount !== startingTagCount) {\n    return {\n      error: getLoopPositionProducesInvalidXMLError({\n        tag: first(pair).part.value,\n        offset: [first(pair).part.offset, last(pair).part.offset]\n      })\n    };\n  }\n\n  var _loop = function _loop(i, len) {\n    var _expandTags$i = expandTags[i],\n        contains = _expandTags$i.contains,\n        expand = _expandTags$i.expand,\n        onlyTextInTag = _expandTags$i.onlyTextInTag;\n\n    if (has(contains, xmlElements)) {\n      if (onlyTextInTag) {\n        var left = getLeftOrNull(postparsed, contains, pair[0].offset);\n        var right = getRightOrNull(postparsed, contains, pair[1].offset);\n\n        if (left === null || right === null) {\n          return \"continue\";\n        }\n\n        var chunks = chunkBy(postparsed.slice(left, right), function (p) {\n          if (isTagStart(contains, p)) {\n            return \"start\";\n          }\n\n          if (isTagEnd(contains, p)) {\n            return \"end\";\n          }\n\n          return null;\n        });\n\n        if (chunks.length <= 2) {\n          return \"continue\";\n        }\n\n        var firstChunk = first(chunks);\n        var lastChunk = last(chunks);\n        var firstContent = firstChunk.filter(isContent);\n        var lastContent = lastChunk.filter(isContent);\n\n        if (firstContent.length !== 1 || lastContent.length !== 1) {\n          return \"continue\";\n        }\n      }\n\n      return {\n        v: {\n          value: expand\n        }\n      };\n    }\n  };\n\n  for (var i = 0, len = expandTags.length; i < len; i++) {\n    var _ret = _loop(i, len);\n\n    if (_ret === \"continue\") continue;\n    if (_typeof(_ret) === \"object\") return _ret.v;\n  }\n\n  return false;\n}\n\nfunction expandOne(part, index, postparsed, options) {\n  var expandTo = part.expandTo || options.expandTo;\n\n  if (!expandTo) {\n    return postparsed;\n  }\n\n  var right, left;\n\n  try {\n    left = getLeft(postparsed, expandTo, index);\n    right = getRight(postparsed, expandTo, index);\n  } catch (rootError) {\n    if (rootError instanceof XTTemplateError) {\n      throwExpandNotFound(_objectSpread({\n        part: part,\n        rootError: rootError,\n        postparsed: postparsed,\n        expandTo: expandTo,\n        index: index\n      }, options.error));\n    }\n\n    throw rootError;\n  }\n\n  var leftParts = postparsed.slice(left, index);\n  var rightParts = postparsed.slice(index + 1, right + 1);\n  var inner = options.getInner({\n    postparse: options.postparse,\n    index: index,\n    part: part,\n    leftParts: leftParts,\n    rightParts: rightParts,\n    left: left,\n    right: right,\n    postparsed: postparsed\n  });\n\n  if (!inner.length) {\n    inner.expanded = [leftParts, rightParts];\n    inner = [inner];\n  }\n\n  return {\n    left: left,\n    right: right,\n    inner: inner\n  };\n}\n\nfunction expandToOne(postparsed, options) {\n  var errors = [];\n\n  if (postparsed.errors) {\n    errors = postparsed.errors;\n    postparsed = postparsed.postparsed;\n  }\n\n  var results = [];\n\n  for (var i = 0, len = postparsed.length; i < len; i++) {\n    var part = postparsed[i];\n\n    if (part.type === \"placeholder\" && part.module === options.moduleName) {\n      try {\n        var result = expandOne(part, i, postparsed, options);\n        i = result.right;\n        results.push(result);\n      } catch (error) {\n        if (error instanceof XTTemplateError) {\n          errors.push(error);\n        } else {\n          throw error;\n        }\n      }\n    }\n  }\n\n  var newParsed = [];\n  var currentResult = 0;\n\n  for (var _i = 0, _len = postparsed.length; _i < _len; _i++) {\n    var _part = postparsed[_i];\n    var _result = results[currentResult];\n\n    if (_result && _result.left === _i) {\n      newParsed.push.apply(newParsed, _toConsumableArray(results[currentResult].inner));\n      currentResult++;\n      _i = _result.right;\n    } else {\n      newParsed.push(_part);\n    }\n  }\n\n  return {\n    postparsed: newParsed,\n    errors: errors\n  };\n}\n\nmodule.exports = {\n  expandToOne: expandToOne,\n  getExpandToDefault: getExpandToDefault\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/traits.js?");

/***/ }),

/***/ "./es6/utils.js":
/*!**********************!*\
  !*** ./es6/utils.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function last(a) {\n  return a[a.length - 1];\n}\n\nfunction first(a) {\n  return a[0];\n}\n\nmodule.exports = {\n  last: last,\n  first: first\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/utils.js?");

/***/ }),

/***/ "./es6/xml-matcher.js":
/*!****************************!*\
  !*** ./es6/xml-matcher.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // res class responsibility is to parse the XML.\n\nvar _require = __webpack_require__(/*! ./doc-utils */ \"./es6/doc-utils.js\"),\n    pregMatchAll = _require.pregMatchAll;\n\nfunction handleRecursiveCase(res) {\n  /*\n   * Because xmlTemplater is recursive (meaning it can call it self), we need to handle special cases where the XML is not valid:\n   * For example with res string \"I am</w:t></w:r></w:p><w:p><w:r><w:t>sleeping\",\n   *   - we need to match also the string that is inside an implicit <w:t> (that's the role of replacerUnshift) (in res case 'I am')\n   *   - we need to match the string that is at the right of a <w:t> (that's the role of replacerPush) (in res case 'sleeping')\n   * the test: describe \"scope calculation\" it \"should compute the scope between 2 <w:t>\" makes sure that res part of code works\n   * It should even work if they is no XML at all, for example if the code is just \"I am sleeping\", in res case however, they should only be one match\n   */\n  function replacerUnshift() {\n    var pn = {\n      array: Array.prototype.slice.call(arguments)\n    };\n    pn.array.shift();\n    var match = pn.array[0] + pn.array[1]; // add match so that pn[0] = whole match, pn[1]= first parenthesis,...\n\n    pn.array.unshift(match);\n    pn.array.pop();\n    var offset = pn.array.pop();\n    pn.offset = offset;\n    pn.first = true; // add at the beginning\n\n    res.matches.unshift(pn);\n  }\n\n  if (res.content.indexOf(\"<\") === -1 && res.content.indexOf(\">\") === -1) {\n    res.content.replace(/^()([^<>]*)$/, replacerUnshift);\n  }\n\n  var r = new RegExp(\"^()([^<]+)</(?:\".concat(res.tagsXmlArrayJoined, \")>\"));\n  res.content.replace(r, replacerUnshift);\n\n  function replacerPush() {\n    var pn = {\n      array: Array.prototype.slice.call(arguments)\n    };\n    pn.array.pop();\n    var offset = pn.array.pop();\n    pn.offset = offset;\n    pn.last = true;\n\n    if (pn.array[0].indexOf(\"/>\") !== -1) {\n      return;\n    } // add at the end\n\n\n    res.matches.push(pn);\n  }\n\n  r = new RegExp(\"(<(?:\".concat(res.tagsXmlArrayJoined, \")[^>]*>)([^>]+)$\"));\n  res.content.replace(r, replacerPush);\n  return res;\n}\n\nmodule.exports = function xmlMatcher(content, tagsXmlArray) {\n  var res = {};\n  res.content = content;\n  res.tagsXmlArray = tagsXmlArray;\n  res.tagsXmlArrayJoined = res.tagsXmlArray.join(\"|\");\n  var regexp = new RegExp(\"(?:(<(?:\".concat(res.tagsXmlArrayJoined, \")[^>]*>)([^<>]*)</(?:\").concat(res.tagsXmlArrayJoined, \")>)|(<(?:\").concat(res.tagsXmlArrayJoined, \")[^>]*/>)\"), \"g\");\n  res.matches = pregMatchAll(regexp, res.content);\n  return handleRecursiveCase(res);\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/xml-matcher.js?");

/***/ }),

/***/ "./es6/xml-templater.js":
/*!******************************!*\
  !*** ./es6/xml-templater.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar _require = __webpack_require__(/*! ./doc-utils */ \"./es6/doc-utils.js\"),\n    wordToUtf8 = _require.wordToUtf8,\n    convertSpaces = _require.convertSpaces,\n    defaults = _require.defaults;\n\nvar xmlMatcher = __webpack_require__(/*! ./xml-matcher */ \"./es6/xml-matcher.js\");\n\nvar _require2 = __webpack_require__(/*! ./errors */ \"./es6/errors.js\"),\n    throwContentMustBeString = _require2.throwContentMustBeString;\n\nvar Lexer = __webpack_require__(/*! ./lexer */ \"./es6/lexer.js\");\n\nvar Parser = __webpack_require__(/*! ./parser.js */ \"./es6/parser.js\");\n\nvar _render = __webpack_require__(/*! ./render.js */ \"./es6/render.js\");\n\nvar postrender = __webpack_require__(/*! ./postrender.js */ \"./es6/postrender.js\");\n\nvar resolve = __webpack_require__(/*! ./resolve.js */ \"./es6/resolve.js\");\n\nvar joinUncorrupt = __webpack_require__(/*! ./join-uncorrupt */ \"./es6/join-uncorrupt.js\");\n\nfunction _getFullText(content, tagsXmlArray) {\n  var matcher = xmlMatcher(content, tagsXmlArray);\n  var result = matcher.matches.map(function (match) {\n    return match.array[2];\n  });\n  return wordToUtf8(convertSpaces(result.join(\"\")));\n}\n\nmodule.exports = /*#__PURE__*/function () {\n  function XmlTemplater(content, options) {\n    _classCallCheck(this, XmlTemplater);\n\n    this.filePath = options.filePath;\n    this.cachedParsers = {};\n    this.modules = options.modules;\n    this.fileTypeConfig = options.fileTypeConfig;\n    this.contentType = options.contentType;\n    Object.keys(defaults).map(function (key) {\n      this[key] = options[key] != null ? options[key] : defaults[key];\n    }, this);\n    this.setModules({\n      inspect: {\n        filePath: this.filePath\n      }\n    });\n    this.load(content);\n  }\n\n  _createClass(XmlTemplater, [{\n    key: \"load\",\n    value: function load(content) {\n      if (typeof content !== \"string\") {\n        throwContentMustBeString(_typeof(content));\n      }\n\n      this.content = content;\n    }\n  }, {\n    key: \"setTags\",\n    value: function setTags(tags) {\n      this.tags = tags != null ? tags : {};\n      return this;\n    }\n  }, {\n    key: \"resolveTags\",\n    value: function resolveTags(tags) {\n      var _this = this;\n\n      this.tags = tags != null ? tags : {};\n      var options = this.getOptions();\n      options.scopeManager = this.scopeManager;\n      options.resolve = resolve;\n      return resolve(options).then(function (_ref) {\n        var resolved = _ref.resolved,\n            errors = _ref.errors;\n        errors.forEach(function (error) {\n          // error properties might not be defined if some foreign\n          // (unhandled error not throw by docxtemplater willingly) is\n          // thrown.\n          error.properties = error.properties || {};\n          error.properties.file = _this.filePath;\n        });\n\n        if (errors.length !== 0) {\n          throw errors;\n        }\n\n        return Promise.all(resolved).then(function (resolved) {\n          options.scopeManager.finishedResolving = true;\n          options.scopeManager.resolved = resolved;\n\n          _this.setModules({\n            inspect: {\n              resolved: resolved\n            }\n          });\n\n          return resolved;\n        });\n      });\n    }\n  }, {\n    key: \"getFullText\",\n    value: function getFullText() {\n      return _getFullText(this.content, this.fileTypeConfig.tagsXmlTextArray);\n    }\n  }, {\n    key: \"setModules\",\n    value: function setModules(obj) {\n      this.modules.forEach(function (module) {\n        module.set(obj);\n      });\n    }\n  }, {\n    key: \"preparse\",\n    value: function preparse() {\n      this.allErrors = [];\n      this.xmllexed = Lexer.xmlparse(this.content, {\n        text: this.fileTypeConfig.tagsXmlTextArray,\n        other: this.fileTypeConfig.tagsXmlLexedArray\n      });\n      this.setModules({\n        inspect: {\n          xmllexed: this.xmllexed\n        }\n      });\n\n      var _Lexer$parse = Lexer.parse(this.xmllexed, this.delimiters),\n          lexed = _Lexer$parse.lexed,\n          lexerErrors = _Lexer$parse.errors;\n\n      this.allErrors = this.allErrors.concat(lexerErrors);\n      this.lexed = lexed;\n      this.setModules({\n        inspect: {\n          lexed: this.lexed\n        }\n      });\n      var options = this.getOptions();\n      Parser.preparse(this.lexed, this.modules, options);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse() {\n      this.setModules({\n        inspect: {\n          filePath: this.filePath\n        }\n      });\n      var options = this.getOptions();\n      this.parsed = Parser.parse(this.lexed, this.modules, options);\n      this.setModules({\n        inspect: {\n          parsed: this.parsed\n        }\n      });\n\n      var _Parser$postparse = Parser.postparse(this.parsed, this.modules, options),\n          postparsed = _Parser$postparse.postparsed,\n          postparsedErrors = _Parser$postparse.errors;\n\n      this.postparsed = postparsed;\n      this.setModules({\n        inspect: {\n          postparsed: this.postparsed\n        }\n      });\n      this.allErrors = this.allErrors.concat(postparsedErrors);\n      this.errorChecker(this.allErrors);\n      return this;\n    }\n  }, {\n    key: \"errorChecker\",\n    value: function errorChecker(errors) {\n      var _this2 = this;\n\n      if (errors.length) {\n        errors.forEach(function (error) {\n          // error properties might not be defined if some foreign\n          // (unhandled error not thrown by docxtemplater willingly) is\n          // thrown.\n          error.properties = error.properties || {};\n          error.properties.file = _this2.filePath;\n        });\n        this.modules.forEach(function (module) {\n          errors = module.errorsTransformer(errors);\n        });\n      }\n    }\n  }, {\n    key: \"baseNullGetter\",\n    value: function baseNullGetter(part, sm) {\n      var _this3 = this;\n\n      var value = this.modules.reduce(function (value, module) {\n        if (value != null) {\n          return value;\n        }\n\n        return module.nullGetter(part, sm, _this3);\n      }, null);\n\n      if (value != null) {\n        return value;\n      }\n\n      return this.nullGetter(part, sm);\n    }\n  }, {\n    key: \"getOptions\",\n    value: function getOptions() {\n      return {\n        compiled: this.postparsed,\n        cachedParsers: this.cachedParsers,\n        tags: this.tags,\n        modules: this.modules,\n        parser: this.parser,\n        contentType: this.contentType,\n        baseNullGetter: this.baseNullGetter.bind(this),\n        filePath: this.filePath,\n        fileTypeConfig: this.fileTypeConfig,\n        linebreaks: this.linebreaks\n      };\n    }\n  }, {\n    key: \"render\",\n    value: function render(to) {\n      this.filePath = to;\n      var options = this.getOptions();\n      options.resolved = this.scopeManager.resolved;\n      options.scopeManager = this.scopeManager;\n      options.render = _render;\n      options.joinUncorrupt = joinUncorrupt;\n\n      var _render2 = _render(options),\n          errors = _render2.errors,\n          parts = _render2.parts;\n\n      this.allErrors = errors;\n      this.errorChecker(errors);\n\n      if (errors.length > 0) {\n        return this;\n      }\n\n      this.content = postrender(parts, options);\n      this.setModules({\n        inspect: {\n          content: this.content\n        }\n      });\n      return this;\n    }\n  }]);\n\n  return XmlTemplater;\n}();\n\n//# sourceURL=webpack://docxtemplater/./es6/xml-templater.js?");

/***/ })

/******/ });